{"mappings":"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","sources":["src/Petrallengine.ts","src/Snowflake.ts","src/Game.ts","src/nodes/IDrawable.ts","src/nodes/IDebugDrawable.ts","src/nodes/Body.ts","src/nodes/Node.ts","src/structures/Vec2.ts","src/Math.ts","src/structures/Mat3.ts","src/nodes/Collider.ts","src/structures/Bounds.ts","src/systems/Camera.ts","src/systems/Input.ts","src/systems/Physics.ts","src/nodes/CircleCollider.ts","src/nodes/ConvexCollider.ts","src/nodes/LineCollider.ts","src/nodes/RigidBody.ts","src/nodes/Sprite.ts","src/structures/Color.ts"],"sourcesContent":["/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nexport * from \"./Snowflake\";\r\nexport { default as Game } from \"./Game\";\r\n\r\nexport { default as Body } from \"./nodes/Body\";\r\nexport { default as CircleCollider } from \"./nodes/CircleCollider\";\r\nexport { default as Collider } from \"./nodes/Collider\";\r\nexport { type default as IDebugDrawable } from \"./nodes/IDebugDrawable\";\r\nexport { type default as IDrawable } from \"./nodes/IDrawable\";\r\nexport { default as LineCollider } from \"./nodes/LineCollider\";\r\nexport { default as Node } from \"./nodes/Node\";\r\nexport { default as RigidBody } from \"./nodes/RigidBody\";\r\nexport { default as Sprite } from \"./nodes/Sprite\";\r\n\r\nexport { default as Bounds } from \"./structures/Bounds\";\r\nexport { default as Color } from \"./structures/Color\";\r\nexport { type default as ICopyable } from \"./structures/ICopyable\";\r\nexport { type default as IEquatable } from \"./structures/IEquatable\";\r\nexport { default as Mat3 } from \"./structures/Mat3\";\r\nexport { default as Vec2 } from \"./structures/Vec2\";\r\n\r\nexport { default as Camera } from \"./systems/Camera\";\r\nexport { default as Input } from \"./systems/Input\";\r\nexport { default as Physics } from \"./systems/Physics\";\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\n// Adds two arrays for the given base (10 or 16), returning the result.\r\n// This turns out to be the only \"primitive\" operation we need.\r\nfunction add(x: number[], y: number[], base: number) {\r\n    let z: number[] = [];\r\n    let n = Math.max(x.length, y.length);\r\n    let carry = 0;\r\n    let i = 0;\r\n    while (i < n || carry) {\r\n        let xi = i < x.length ? x[i] : 0;\r\n        let yi = i < y.length ? y[i] : 0;\r\n        let zi = carry + xi + yi;\r\n        z.push(zi % base);\r\n        carry = Math.floor(zi / base);\r\n        i++;\r\n    }\r\n    return z;\r\n}\r\n\r\n// Returns a*x, where x is an array of decimal digits and a is an ordinary\r\n// JavaScript number. base is the number base of the array x.\r\nfunction multiplyByNumber(num: number, x: number[], base: number) {\r\n    if (num < 0 || num == 0) return [];\r\n\r\n    let result: number[] = [];\r\n    let power = x;\r\n    while (true) {\r\n        if (num & 1) {\r\n            result = add(result, power, base);\r\n        }\r\n        num = num >> 1;\r\n        if (num === 0) break;\r\n        power = add(power, power, base);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction parseToDigitsArray(str: string, base: number) {\r\n    let digits = str.split('');\r\n    let ary: number[] = [];\r\n    for (let i = digits.length - 1; i >= 0; i--) {\r\n        let n = parseInt(digits[i], base);\r\n        if (isNaN(n)) return null;\r\n        ary.push(n);\r\n    }\r\n    return ary;\r\n}\r\n\r\nfunction convertBase(str: string, fromBase: number, toBase: number) {\r\n    let digits = parseToDigitsArray(str, fromBase);\r\n    if (digits === null) return null;\r\n\r\n    let outArray: number[] = [];\r\n    let power = [1];\r\n    for (let i = 0; i < digits.length; i++) {\r\n        // invariant: at this point, fromBase^i = power\r\n        if (digits[i]) {\r\n            outArray = add(outArray, multiplyByNumber(digits[i], power, toBase), toBase);\r\n        }\r\n        power = multiplyByNumber(fromBase, power, toBase);\r\n    }\r\n\r\n    let out = '';\r\n    for (let i = outArray.length - 1; i >= 0; i--) {\r\n        out += outArray[i].toString(toBase);\r\n    }\r\n    return out;\r\n}\r\n\r\nfunction decToHex(decStr: string) {\r\n    let hex = convertBase(decStr, 10, 16);\r\n    return hex ? '0x' + hex : null;\r\n}\r\n\r\nfunction hexToDec(hexStr: string) {\r\n    if (hexStr.substring(0, 2) === '0x') hexStr = hexStr.substring(2);\r\n    hexStr = hexStr.toLowerCase();\r\n    return convertBase(hexStr, 16, 10);\r\n}\r\n\r\n/**\r\n * A Snowflake ID.\r\n */\r\nexport type Snowflake = string;\r\n\r\nclass SnowflakeFactory {\r\n    private static readonly TIME_BYTES = 4;\r\n    private static readonly RANDOM_BYTES = 2;\r\n    private static readonly INCREMENT_BYTES = 2;\r\n\r\n    private static increment = 0;\r\n\r\n    static make = () => {\r\n        let id = \"\";\r\n        id += Date.now().toString(16).slice(-SnowflakeFactory.TIME_BYTES * 2).padStart(SnowflakeFactory.TIME_BYTES * 2, '0');\r\n        id += Math.round(Math.random() * Math.pow(256, SnowflakeFactory.RANDOM_BYTES)).toString(16).padStart(SnowflakeFactory.RANDOM_BYTES * 2, '0');\r\n        id += SnowflakeFactory.inc.toString(16).padStart(SnowflakeFactory.INCREMENT_BYTES * 2, '0');\r\n        return id;\r\n    }\r\n\r\n    private static get inc() {\r\n        const lim = Math.pow(256, SnowflakeFactory.INCREMENT_BYTES);\r\n        if (++SnowflakeFactory.increment >= lim) { SnowflakeFactory.increment -= lim; }\r\n        return SnowflakeFactory.increment;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a unique Snowflake ID.\r\n * @returns A unique Snowflake ID.\r\n */\r\nexport const makeSnowflake: () => Snowflake = SnowflakeFactory.make;\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport { isDrawable } from './nodes/IDrawable';\r\nimport { isDebugDrawable } from './nodes/IDebugDrawable';\r\nimport Body from './nodes/Body';\r\nimport Collider from './nodes/Collider';\r\nimport Node from './nodes/Node';\r\nimport Camera from './systems/Camera';\r\nimport Input from './systems/Input';\r\nimport Physics from './systems/Physics';\r\n\r\n/**\r\n * Static class for Petrallengine.\r\n * \r\n * Call `Petrallengine.create(MY_CANVAS_ELEMENT)` to start building your 2D browser application.\r\n */\r\nexport default class Game {\r\n    /** The build number. */\r\n    static readonly BUILD = 1;\r\n    /** The version. */\r\n    static readonly VERSION = \"0.0.1\";\r\n    /** The number of scheduled frame updates per second. */\r\n    static readonly FRAME_RATE = 60;\r\n    /** The scheduled interval between frame updates in seconds. */\r\n    static readonly FRAME_TIME = 1 / Game.FRAME_RATE;\r\n    /** Debug draw flags. */\r\n    static readonly DEBUG_DRAWS = {\r\n        colliders: true,\r\n        boundingBoxes: true,\r\n    };\r\n\r\n    private static _deltaTime = Game.FRAME_TIME;\r\n    private static _time = 0;\r\n    private static rootNode: Node = new Node(Game, \"_ROOT_\");\r\n\r\n    /** The root node of the whole game. */\r\n    static get root() {\r\n        return Game.rootNode;\r\n    }\r\n\r\n    /**\r\n     * Initialises the engine.\r\n     * @param target The target canvas element to render onto.\r\n     */\r\n    static create(target?: HTMLCanvasElement) {\r\n        console.debug(`%cPetrallengine v${Game.VERSION}\\nby Petraller`, 'color: #0799ce');\r\n        console.debug(`https://petraller.com/`);\r\n\r\n        // Fallback target\r\n        if (!target) {\r\n            const targetDefaultID = 'app';\r\n            console.debug(`No canvas provided, using default target canvas #${targetDefaultID}`);\r\n\r\n            const ele = document.getElementById(targetDefaultID);\r\n            if (!ele || !(ele instanceof HTMLCanvasElement)) {\r\n                console.error(`Unable to find a canvas with ID #${targetDefaultID}`);\r\n                console.error(`Please create a canvas element with ID #${targetDefaultID}, or provide your own canvas to Petrallengine.create`);\r\n                return;\r\n            }\r\n\r\n            target = ele as HTMLCanvasElement;\r\n        }\r\n\r\n        console.debug(`Using ${target.outerHTML} as render canvas`);\r\n\r\n        // Initialise systems\r\n        const input = new Input(target);\r\n        const physics = new Physics();\r\n\r\n        // Get context\r\n        const canvas = target;\r\n        const context = canvas.getContext('2d')!;\r\n\r\n        // Create game loop\r\n        const ft = 1000 / Game.FRAME_RATE;\r\n        const gameLoop = () => {\r\n            const tStart = Date.now();\r\n\r\n            // Update all\r\n            function update(node: Node) {\r\n                if (!node.isEnabled)\r\n                    return;\r\n\r\n                if (!node.isStarted) {\r\n                    node.onStart?.call(node);\r\n                    node.isStarted = true;\r\n\r\n                    if (node instanceof Body) {\r\n                        Physics.registerBody(node);\r\n                    }\r\n                    if (node instanceof Collider) {\r\n                        let curr: Node | null = node.parent;\r\n                        while (curr !== null) {\r\n                            if (curr instanceof Body) {\r\n                                Physics.registerCollider(node, curr);\r\n                                break;\r\n                            }\r\n                            curr = curr.parent;\r\n                        }\r\n                        if (curr === null) {\r\n                            console.error(`Collider does not have a parent Body, it will not be registered by the Physics system`);\r\n                        }\r\n                    }\r\n                }\r\n                node.onUpdate?.call(node);\r\n                node.globalTransform;\r\n\r\n                // Iterate children\r\n                for (let child of node.children) {\r\n                    update(child);\r\n                }\r\n            }\r\n            update(Game.rootNode);\r\n\r\n            // Physics step\r\n            physics.tick();\r\n\r\n            // Reset\r\n            context.reset();\r\n\r\n            // Clear\r\n            context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n            // Apply camera transforms\r\n            context.translate(canvas.width / 2, canvas.height / 2);\r\n            context.translate(-Camera.position.x, -Camera.position.y);\r\n            context.rotate(-Camera.rotation * Math.PI / 180);\r\n            context.scale(Camera.scale.x, Camera.scale.y);\r\n\r\n            // Draw all\r\n            function draw(node: Node) {\r\n                if (!node.isEnabled)\r\n                    return;\r\n\r\n                // Draw drawables\r\n                if (isDrawable(node)) {\r\n                    context.save();\r\n\r\n                    // Apply node transforms\r\n                    context.transform(\r\n                        node.globalTransform.get(0, 0), node.globalTransform.get(1, 0),\r\n                        node.globalTransform.get(0, 1), node.globalTransform.get(1, 1),\r\n                        node.globalTransform.get(0, 2), node.globalTransform.get(1, 2)\r\n                    );\r\n\r\n                    node.onDraw.call(node, context);\r\n\r\n                    context.restore();\r\n                }\r\n\r\n                // Iterate children\r\n                for (let child of node.children) {\r\n                    draw(child);\r\n                }\r\n            }\r\n            draw(Game.rootNode);\r\n\r\n            // Debug draw\r\n            function debugDraw(node: Node) {\r\n                if (!node.isEnabled)\r\n                    return;\r\n\r\n                // // Draw colliders\r\n                // if (isCollider(node)) {\r\n                //     // Draw debug\r\n                //     node.debugDraw(context);\r\n                // }\r\n\r\n                // Draw drawables\r\n                if (isDebugDrawable(node)) {\r\n                    context.save();\r\n\r\n                    node.onDebugDraw.call(node, context);\r\n\r\n                    context.restore();\r\n                }\r\n\r\n                // Iterate children\r\n                for (let child of node.children) {\r\n                    debugDraw(child);\r\n                }\r\n            }\r\n            debugDraw(Game.rootNode);\r\n\r\n            // Physics general debug draw\r\n            for (let contact of physics.debugContacts) {\r\n                context.strokeStyle = \"#ff0000\";\r\n                context.beginPath();\r\n                context.arc(contact[0].x, contact[0].y, 4, 0, 360);\r\n                context.stroke();\r\n\r\n                physics.debugContacts.set(contact[0], contact[1] - this.deltaTime);\r\n                if (contact[1] < 0)\r\n                    physics.debugContacts.delete(contact[0]);\r\n            }\r\n\r\n            // Clear transition flags\r\n            input.endFrame();\r\n\r\n            const tEnd = Date.now();\r\n            const dt = tEnd - tStart;\r\n            const wait = Math.max(ft - dt, 1);\r\n            Game._time += (Game._deltaTime = dt + wait);\r\n            setTimeout(gameLoop, wait);\r\n        };\r\n        gameLoop();\r\n    }\r\n\r\n    /**\r\n     * Returns the total elapsed game time in seconds.\r\n     */\r\n    static get time() {\r\n        return Game._time / 1000;\r\n    }\r\n\r\n    /**\r\n     * Returns the actual elapsed time for the frame in seconds.\r\n     */\r\n    static get deltaTime() {\r\n        return Game._deltaTime / 1000;\r\n    }\r\n};\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\n/**\r\n * Checks if an object implements a drawable.\r\n * @param obj The object.\r\n * @returns Whether the object implements a drawable.\r\n */\r\nexport function isDrawable(obj: Object): obj is IDrawable {\r\n    return 'onDraw' in obj && obj.onDraw instanceof Function;\r\n}\r\n\r\n/**\r\n * Interface for all drawables.\r\n */\r\nexport default interface IDrawable {\r\n    /**\r\n     * Called when drawn.\r\n     * @param context The canvas rendering context.\r\n     */\r\n    onDraw(context: CanvasRenderingContext2D): void;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\n/**\r\n * Checks if an object implements a debug drawable.\r\n * @param obj The object.\r\n * @returns Whether the object implements a debug drawable.\r\n */\r\nexport function isDebugDrawable(obj: Object): obj is IDebugDrawable {\r\n    return 'onDebugDraw' in obj && obj.onDebugDraw instanceof Function;\r\n}\r\n\r\n/**\r\n * Interface for all drawables.\r\n */\r\nexport default interface IDebugDrawable {\r\n    /**\r\n     * Called when debug drawn.\r\n     * @param context The canvas rendering context.\r\n     */\r\n    onDebugDraw(context: CanvasRenderingContext2D): void;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Node from './Node';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * Base class for all physics-based nodes that responds to collisions but not physics.\r\n * \r\n * Overrideable callbacks:\r\n * - onCollisionEnter\r\n * - onCollisionUpdate\r\n * - onCollisionExit\r\n */\r\nexport default class Body extends Node {\r\n    private _velocity: Vec2 = Vec2.zero;\r\n\r\n    /** The velocity of this body. */\r\n    get velocity() { return this._velocity; }\r\n    set velocity(value: Vec2) { this._velocity = value; }\r\n\r\n    /**\r\n     * Called when the node first collides with another body.\r\n     * @param other The colliding body.\r\n     */\r\n    onCollisionEnter?(other: Body): void;\r\n\r\n    /**\r\n     * Called while the node is colliding with another body.\r\n     * @param other The colliding body.\r\n     */\r\n    onCollisionUpdate?(other: Body): void;\r\n\r\n    /**\r\n     * Called when the node stops colliding with another body.\r\n     * @param other The colliding body.\r\n     */\r\n    onCollisionExit?(other: Body): void;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport { Snowflake, makeSnowflake } from '../Snowflake';\r\nimport Vec2 from '../structures/Vec2';\r\nimport Mat3 from '../structures/Mat3';\r\n\r\nexport type Constructor<T> = { new(...args: any[]): T };\r\n\r\n/**\r\n * Base class for all nodes in the scene tree.\r\n * \r\n * Overrideable callbacks:\r\n * - onCreate\r\n * - onStart\r\n * - onDestroy\r\n * - onEnable\r\n * - onDisable\r\n * - onUpdate\r\n */\r\nexport default class Node {\r\n    private _isEnabled: boolean = true;\r\n    private _position: Vec2 = Vec2.zero;\r\n    private _rotation: number = 0;\r\n    private _scale: Vec2 = Vec2.one;\r\n    private _parent: Node | null = null;\r\n    private _transform: Mat3 = Mat3.identity;\r\n    private _globalTransform: Mat3 = Mat3.identity;\r\n    private _isDirty = false;\r\n\r\n    /** The unique Snowflake ID of this node. */\r\n    readonly id: Snowflake = makeSnowflake();\r\n\r\n    /** The name of this node. */\r\n    name: string = \"New Node\";\r\n    /** The children nodes of this node. */\r\n    children: Node[] = [];\r\n    /** Whether this node has started. */\r\n    isStarted: boolean = false;\r\n\r\n    /**\r\n     * Avoid calling `new Node`, call `Petrallengine.root.createChild` instead.\r\n     */\r\n    constructor(flag?: any, name: string = \"New Node\") {\r\n        if (!flag) {\r\n            console.warn(`Avoid calling \\`new Node\\`, call \\`Petrallengine.root.createChild\\` instead`);\r\n            console.trace(`\\`new Node\\` call occured here:`);\r\n        }\r\n        this.name = name;\r\n    }\r\n\r\n    toString() { return `${this.name}#${this.id}`; }\r\n\r\n    /** The enabled state of this node. */\r\n    get isEnabled() { return this._isEnabled; }\r\n    set isEnabled(value: boolean) {\r\n        this._isEnabled = value;\r\n        if (value) {\r\n            this.onEnable?.call(this);\r\n        }\r\n        else {\r\n            this.onDisable?.call(this);\r\n        }\r\n    }\r\n\r\n    /** The position of this node. */\r\n    get position() { return this._position; }\r\n    set position(value: Vec2) { this._position = value; this._isDirty = true; }\r\n\r\n    /** The global position of this node. */\r\n    get globalPosition() { return this.globalTransform.translation; }\r\n    set globalPosition(value: Vec2) {\r\n        const parent = this.parent ? this.parent.globalTransform : Mat3.identity;\r\n        const parentInverse = Mat3.inverse(parent);\r\n        const local = Mat3.matrixMultiply(parentInverse, Mat3.makeTransformation(value, this._rotation, this._scale));\r\n        this.position = local.translation;\r\n    }\r\n\r\n    /** The rotation in degrees of this node. */\r\n    get rotation() { return this._rotation; }\r\n    set rotation(value: number) { this._rotation = (value + 180) % 360 - 180; this._isDirty = true; }\r\n\r\n    /** The global rotation in degrees of this node. */\r\n    get globalRotation() {\r\n        let rot = this._rotation;\r\n        let curr = this._parent;\r\n        while (curr !== null) {\r\n            rot += curr._rotation;\r\n            curr = curr._parent;\r\n        }\r\n        return rot;\r\n    }\r\n    set globalRotation(value: number) {\r\n        let rot = 0;\r\n        let curr = this._parent;\r\n        while (curr !== null) {\r\n            rot += curr._rotation;\r\n            curr = curr._parent;\r\n        }\r\n        this.rotation = value - rot;\r\n    }\r\n\r\n    /** The scale of this node. */\r\n    get scale() { return this._scale; }\r\n    set scale(value: Vec2) { this._scale = value; this._isDirty = true; }\r\n\r\n    /** The global scale of this node. */\r\n    get globalScale() { return this.globalTransform.scale; }\r\n\r\n    /** The transformation matrix of this node. */\r\n    get transform() { this.recalculateTransformMatrix(); return this._transform; }\r\n\r\n    /** The global transformation matrix of this node. */\r\n    get globalTransform() { this.recalculateTransformMatrix(); return this._globalTransform; }\r\n\r\n    /** The parent node of this node. */\r\n    get parent() { return this._parent; }\r\n    set parent(value: Node | null) {\r\n        if (value && value.isDescendantOf(this)) {\r\n            // Hey stop that. No circular hierarchy pls\r\n            console.error(`Making \\`${value.toString()}\\` a parent of \\`${this.toString()}\\` will create a circular hierarchy`);\r\n            return;\r\n        }\r\n        if (this._parent) {\r\n            const i = this._parent.children.indexOf(this);\r\n            if (i !== -1) {\r\n                this._parent.children.splice(i, 1);\r\n            }\r\n        }\r\n        this._parent = value;\r\n        if (this._parent) {\r\n            this._parent.children.push(this);\r\n        }\r\n    }\r\n\r\n    /** The sibling index of this node. */\r\n    get siblingIndex() {\r\n        if (!this._parent)\r\n            return 0;\r\n        return this._parent.children.indexOf(this);\r\n    }\r\n    set siblingIndex(value: number) {\r\n        if (!this._parent)\r\n            return;\r\n        const i = this.siblingIndex;\r\n        this._parent.children.splice(i, 1);\r\n        this._parent.children.splice(value, 0, this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new child node of this node.\r\n     * @returns The child node.\r\n     */\r\n    createChild<T extends Node>(type: Constructor<T>) {\r\n        const node = new type(this.createChild);\r\n        node.parent = this;\r\n        node.onCreate?.call(node);\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Destroys this node and all children nodes.\r\n     */\r\n    destroy() {\r\n        for (let child of this.children) {\r\n            child.destroy();\r\n        }\r\n        this.onDestroy?.call(this);\r\n        this.parent = null;\r\n    }\r\n\r\n    /**\r\n     * Finds a descendant node by its name.\r\n     * @param name The name of the node.\r\n     * @returns The node, or null if not found.\r\n     */\r\n    findDescendantByName(name: string): Node | null {\r\n        for (let child of this.children) {\r\n            if (child.name == name)\r\n                return child;\r\n        }\r\n        for (let child of this.children) {\r\n            const result = child.findDescendantByName(name);\r\n            if (result)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Finds a descendant node by its type.\r\n     * @param type The type of the node.\r\n     * @returns The node, or null if not found.\r\n     */\r\n    findDescendantByType<T>(type: Constructor<T>): T | null {\r\n        for (let child of this.children) {\r\n            if (child instanceof type)\r\n                return child;\r\n        }\r\n        for (let child of this.children) {\r\n            const result = child.findDescendantByType(type);\r\n            if (result)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Determines if this node is a descendent of another node.\r\n     * @param node The other node.\r\n     * @returns Whether this node is a descendant.\r\n     */\r\n    isDescendantOf(node: Node) {\r\n        let curr = this.parent;\r\n        while (curr !== null) {\r\n            if (curr === node)\r\n                return true;\r\n            curr = curr.parent;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Recalculates the transformation matrices and unsets the dirty flag.\r\n     */\r\n    private recalculateTransformMatrix() {\r\n        if (!this._isDirty)\r\n            return;\r\n\r\n        // Calculate\r\n        this._transform = Mat3.makeTransformation(this._position, this._rotation, this._scale);\r\n        if (this.parent)\r\n            this._globalTransform = Mat3.matrixMultiply(this.parent.globalTransform, this._transform);\r\n        else\r\n            this._globalTransform = this._transform.copy();\r\n\r\n        // Dirty children\r\n        for (const child of this.children) {\r\n            child._isDirty = true;\r\n        }\r\n\r\n        this._isDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Called when the node is created.\r\n     */\r\n    onCreate?(): void;\r\n\r\n    /**\r\n     * Called when the node is first ticked.\r\n     */\r\n    onStart?(): void;\r\n\r\n    /**\r\n     * Called when the node is destroyed.\r\n     */\r\n    onDestroy?(): void;\r\n\r\n    /**\r\n     * Called when the node is enabled.\r\n     */\r\n    onEnable?(): void;\r\n\r\n    /**\r\n     * Called when the node is disabled.\r\n     */\r\n    onDisable?(): void;\r\n\r\n    /**\r\n     * Called when the node is ticked.\r\n     */\r\n    onUpdate?(): void;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\nimport Mat3 from './Mat3';\r\n\r\n/**\r\n * Representation of a 2D vector.\r\n */\r\nexport default class Vec2 implements ICopyable, IEquatable {\r\n    private _x: number = 0;\r\n    private _y: number = 0;\r\n\r\n    constructor(x: number, y: number) {\r\n        this._x = x;\r\n        this._y = y;\r\n    }\r\n\r\n    copy = () => new Vec2(this.x, this.y);\r\n    equals = (other: Vec2) => this.x === other.x && this.y === other.y;\r\n\r\n    /** The x-component. */\r\n    get x() { return this._x; }\r\n\r\n    /** The y-component. */\r\n    get y() { return this._y; }\r\n\r\n    /** The squared length of this vector. */\r\n    get sqrLength() { return this.x * this.x + this.y * this.y; }\r\n\r\n    /** The length of this vector. */\r\n    get length() { return Math.sqrt(this.sqrLength); }\r\n\r\n    /** The normalized form of this vector. */\r\n    get normalized() { const l = this.length; return l == 0 ? Vec2.zero : Vec2.divide(this, l); };\r\n\r\n    /** A normal to this vector. */\r\n    get normal() { return new Vec2(-this.y, this.x); };\r\n\r\n    /** The value of the minimum component of this vector. */\r\n    get minComponent() { return this.x < this.y ? this.x : this.y; }\r\n\r\n    /** The value of the maximum component of this vector. */\r\n    get maxComponent() { return this.x > this.y ? this.x : this.y; }\r\n\r\n    /** The zero vector. */\r\n    static get zero() { return new Vec2(0, 0); }\r\n    /** The half vector. */\r\n    static get half() { return new Vec2(0.5, 0.5); }\r\n    /** The unit vector. */\r\n    static get one() { return new Vec2(1, 1); }\r\n    /** The right vector. */\r\n    static get right() { return new Vec2(1, 0); }\r\n    /** The left vector. */\r\n    static get left() { return new Vec2(-1, 0); }\r\n    /** The down vector. */\r\n    static get down() { return new Vec2(0, 1); }\r\n    /** The up vector. */\r\n    static get up() { return new Vec2(0, -1); }\r\n    /** The negative infinity vector. */\r\n    static get negativeInfinity() { return new Vec2(-Infinity, -Infinity); }\r\n    /** The infinity vector. */\r\n    static get infinity() { return new Vec2(Infinity, Infinity); }\r\n\r\n    /**\r\n     * Adds two vectors component-wise.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The sum vector.\r\n     */\r\n    static add = (v1: Vec2, v2: Vec2) => new Vec2(v1.x + v2.x, v1.y + v2.y);\r\n\r\n    /**\r\n     * Multiplies a vector by a constant.\r\n     * @param v The vector.\r\n     * @param n The constant\r\n     * @returns The scaled vector.\r\n     */\r\n    static multiply = (v: Vec2, n: number) => new Vec2(v.x * n, v.y * n);\r\n\r\n    /**\r\n     * Multiplies two vectors component-wise.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The scaled vector.\r\n     */\r\n    static multiplyComponents = (v1: Vec2, v2: Vec2) => new Vec2(v1.x * v2.x, v1.y * v2.y);\r\n\r\n    /**\r\n     * Subtracts one vector from another.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The difference vector.\r\n     */\r\n    static subtract = (v1: Vec2, v2: Vec2) => Vec2.add(v1, Vec2.multiply(v2, -1));\r\n\r\n    /**\r\n     * Divides a vector by a constant.\r\n     * @param v The vector.\r\n     * @param n The constant.\r\n     * @returns The scaled vector.\r\n     */\r\n    static divide = (v: Vec2, n: number) => Vec2.multiply(v, 1 / n);\r\n\r\n    /**\r\n     * Inverts a vector component-wise.\r\n     * @param v The vector.\r\n     * @returns The inverted vector.\r\n     */\r\n    static inverse = (v: Vec2) => new Vec2(1 / v.x, 1 / v.y);\r\n\r\n    /**\r\n     * Dot multiplies two vectors.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The dot product.\r\n     */\r\n    static dot = (v1: Vec2, v2: Vec2) => v1.x * v2.x + v1.y * v2.y;\r\n\r\n    /**\r\n     * Cross multiplies two vectors.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The magnitude of the cross product.\r\n     */\r\n    static cross = (v1: Vec2, v2: Vec2) => v1.x * v2.y - v1.y * v2.x;\r\n\r\n    /**\r\n     * Rotates a vector by an angle.\r\n     * @param deg The angle in degrees.\r\n     * @returns The rotated vector.\r\n     */\r\n    static rotate = (v: Vec2, deg: number) => {\r\n        const r = deg * Math.PI / 180;\r\n        const x = Math.cos(r) * v.x - Math.sin(r) * v.y;\r\n        const y = Math.sin(r) * v.x + Math.cos(r) * v.y;\r\n        return new Vec2(x, y);\r\n    };\r\n\r\n    /**\r\n     * Transforms a vector by a matrix.\r\n     * @param m The matrix.\r\n     * @param v The vector.\r\n     * @returns The transformed vector.\r\n     */\r\n    static transform = (m: Mat3, v: Vec2) => {\r\n        const x = v.x * m.get(0, 0) + v.y * m.get(0, 1) + m.get(0, 2);\r\n        const y = v.x * m.get(1, 0) + v.y * m.get(1, 1) + m.get(1, 2);\r\n        return new Vec2(x, y);\r\n    };\r\n\r\n    /**\r\n     * Converts an angle in degrees to a unit vector.\r\n     * @param deg The angle in degrees.\r\n     * @returns The vector.\r\n     */\r\n    static fromAngle = (deg: number) => { const r = deg * Math.PI / 180; return new Vec2(Math.cos(r), Math.sin(r)); };\r\n\r\n    /**\r\n     * Converts a vector to its angle from the x-axis.\r\n     * @param v The vector.\r\n     * @returns The angle in degrees.\r\n     */\r\n    static toAngle = (v: Vec2) => {\r\n        if (v.x == 0)\r\n            return v.y >= 0 ? 90 : -90;\r\n        return (v.x > 0 ? 0 : (v.y > 0 ? 180 : -180)) + Math.atan(v.y / v.x) * 180 / Math.PI;\r\n    }\r\n\r\n    /**\r\n     * Converts an arbitrary object with x and y properties to a vector.\r\n     * @param obj The object.\r\n     * @returns The vector.\r\n     */\r\n    static fromObjXY = (obj: { x: number, y: number }) => new Vec2(obj.x, obj.y);\r\n\r\n    /**\r\n     * Converts an arbitrary object with width and height properties to a vector.\r\n     * @param obj The object.\r\n     * @returns The vector.\r\n     */\r\n    static fromObjWH = (obj: { width: number, height: number }) => new Vec2(obj.width, obj.height);\r\n\r\n    /**\r\n     * Converts a 3-tuple to a vector, omitting the last element of the tuple.\r\n     * @param obj The 3-tuple.\r\n     * @returns The vector.\r\n     */\r\n    static from3Tuple = (obj: [number, number, number]) => new Vec2(obj[0], obj[1]);\r\n\r\n    /**\r\n     * Linearly interpolates from one vector to another.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated vector.\r\n     */\r\n    static lerp = (v1: Vec2, v2: Vec2, t: number) => new Vec2(Math.lerp(v1.x, v2.x, t), Math.lerp(v1.y, v2.y, t));\r\n\r\n    /**\r\n     * Linearly interpolates from one vector to another.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated vector.\r\n     */\r\n    static lerpComponents = (v1: Vec2, v2: Vec2, t: Vec2) => new Vec2(Math.lerp(v1.x, v2.x, t.x), Math.lerp(v1.y, v2.y, t.y));\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\n/** */\r\ninterface Math {\r\n    /**\r\n     * Linearly interpolates from one value to another.\r\n     * @param x The first value.\r\n     * @param y The second value.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated value.\r\n     */\r\n    lerp(x: number, y: number, t: number): number;\r\n\r\n    /**\r\n     * Clamps a value between two values.\r\n     * @param x The value to clamp.\r\n     * @param min The minimum value.\r\n     * @param max The maximum value.\r\n     * @returns The clamped value.\r\n     */\r\n    clamp(x: number, min: number, max: number): number;\r\n\r\n    /**\r\n     * Performs a modified modulo operation on two numbers.\r\n     * \r\n     * The operation will yield the positive remainder of the dividend divided by the absolute value of the divisor.\r\n     * @param x The dividend.\r\n     * @param y The divisor.\r\n     * @returns The remainder.\r\n     */\r\n    mod(x: number, y: number): number;\r\n}\r\n\r\nMath.lerp = (x: number, y: number, t: number) => x * (1 - t) + y * t;\r\nMath.clamp = (x: number, min: number, max: number) => Math.min(Math.max(x, min), max);\r\nMath.mod = (x: number, y: number) => (x >= 0) ? (x % Math.abs(y)) : (Math.abs(y) - (-x % Math.abs((y))) % Math.abs(y));\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\nimport Vec2 from './Vec2';\r\n\r\ntype Row = [number, number, number];\r\ntype Column = [number, number, number];\r\ntype Matrix = [Row, Row, Row]; /* your boat */\r\n\r\n/**\r\n * Representation of a 3x3 matrix.\r\n */\r\nexport default class Mat3 implements ICopyable, IEquatable {\r\n    /** The matrix. */\r\n    private _m: Matrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\r\n\r\n    constructor(m?: Matrix) {\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                this._m[r][c] = m ? m[r][c] : 0;\r\n    }\r\n\r\n    copy = () => new Mat3(this._m);\r\n    equals = (other: Mat3) => {\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                if (this._m[r][c] !== other._m[r][c])\r\n                    return false;\r\n        return true;\r\n    }\r\n\r\n    /** The determinant of this matrix. */\r\n    get determinant() {\r\n        return this._m[0][0] * (this._m[1][1] * this._m[2][2] - this._m[1][2] * this._m[2][1]) +\r\n            this._m[0][1] * (this._m[1][2] * this._m[2][0] - this._m[1][0] * this._m[2][2]) +\r\n            this._m[0][2] * (this._m[1][0] * this._m[2][1] - this._m[1][1] * this._m[2][0]);\r\n    }\r\n\r\n    /** The translation component of the matrix. */\r\n    get translation() { return Vec2.from3Tuple(this.getColumn(2)); }\r\n    set translation(value: Vec2) { this.set(0, 2, value.x).set(1, 2, value.y); }\r\n\r\n    /** The non-negative scale component of the matrix. */\r\n    get scale() { return new Vec2(Vec2.from3Tuple(this.getColumn(0)).length, Vec2.from3Tuple(this.getColumn(1)).length); }\r\n\r\n    /**\r\n     * Retrieves an element of the matrix.\r\n     * @param r The row index.\r\n     * @param c The column index.\r\n     * @returns The element.\r\n     */\r\n    get = (r: number, c: number) => this._m[r][c];\r\n\r\n    /**\r\n     * Sets an element of the matrix.\r\n     * @param r The row index.\r\n     * @param c The column index.\r\n     * @param value The value.\r\n     * @returns This matrix after setting.\r\n     */\r\n    set = (r: number, c: number, value: number) => { this._m[r][c] = value; return this; }\r\n\r\n    /**\r\n     * Retrieves a row of the matrix.\r\n     * @param r The row index.\r\n     * @returns The row.\r\n     */\r\n    getRow = (r: number): Row => [this._m[r][0], this._m[r][1], this._m[r][2]];\r\n\r\n    /**\r\n     * Retrieves a column of the matrix.\r\n     * @param c The column index.\r\n     * @returns The column.\r\n     */\r\n    getColumn = (c: number): Column => [this._m[0][c], this._m[1][c], this._m[2][c]];\r\n\r\n    /**\r\n     * Retrieves a minor of the matrix.\r\n     * @param r The row index to omit.\r\n     * @param c The column index to omit.\r\n     * @returns The minor.\r\n     */\r\n    private getMinor = (r: number, c: number): [[number, number], [number, number]] => [\r\n        r == 0\r\n            ? [c == 0 ? this._m[1][1] : this._m[1][0], c == 2 ? this._m[1][1] : this._m[1][2]]\r\n            : [c == 0 ? this._m[0][1] : this._m[0][0], c == 2 ? this._m[0][1] : this._m[0][2]],\r\n        r == 2\r\n            ? [c == 0 ? this._m[1][1] : this._m[1][0], c == 2 ? this._m[1][1] : this._m[1][2]]\r\n            : [c == 0 ? this._m[2][1] : this._m[2][0], c == 2 ? this._m[2][1] : this._m[2][2]]\r\n    ];\r\n\r\n    /**\r\n     * Retrieves the determinant of a cofactor of the matrix.\r\n     * @param r The row index of the element.\r\n     * @param c The column index of the element.\r\n     * @returns The determinant of the cofactor.\r\n     */\r\n    private getCofactorDeterminant = (r: number, c: number) => {\r\n        let minor = this.getMinor(r, c);\r\n        let i = (r + c) % 2 === 0 ? 1 : -1;\r\n        return i * (minor[0][0] * minor[1][1] - minor[1][0] * minor[0][1]);\r\n    }\r\n\r\n    /** The zero matrix. */\r\n    static get zero() { return new Mat3([[0, 0, 0], [0, 0, 0], [0, 0, 0]]); }\r\n    /** The identity matrix. */\r\n    static get identity() { return new Mat3([[1, 0, 0], [0, 1, 0], [0, 0, 1]]); }\r\n\r\n    /**\r\n     * Adds two matrices component-wise.\r\n     * \r\n     * Does not modify the original matrices.\r\n     * @param m1 The first matrix.\r\n     * @param m2 The second matrix.\r\n     * @returns The sum matrix.\r\n     */\r\n    static add = (m1: Mat3, m2: Mat3) => {\r\n        let result = new Mat3();\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                result._m[r][c] = m1._m[r][c] + m2._m[r][c];\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Multiplies a matrix by a constant.\r\n     * \r\n     * Does not modify the original matrix.\r\n     * @param m The matrix.\r\n     * @param n The constant\r\n     * @returns The scaled matrix.\r\n     */\r\n    static multiply = (m: Mat3, n: number) => {\r\n        let result = new Mat3();\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                result._m[r][c] = m._m[r][c] * n;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Multiplies two matrices.\r\n     * \r\n     * Does not modify the original matrices.\r\n     * @param m1 The first matrix.\r\n     * @param m2 The second matrix.\r\n     * @returns The multiplied matrix.\r\n     */\r\n    static matrixMultiply = (m1: Mat3, m2: Mat3) => {\r\n        let result = new Mat3();\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                for (let i = 0; i < 3; ++i)\r\n                    result._m[r][c] += m1._m[r][i] * m2._m[i][c];\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Subtracts one matrix from another.\r\n     * \r\n     * Does not modify the original matrices.\r\n     * @param m1 The first matrix.\r\n     * @param m2 The second matrix.\r\n     * @returns The difference matrix.\r\n     */\r\n    static subtract = (m1: Mat3, m2: Mat3) => Mat3.add(m1, Mat3.multiply(m2, -1));\r\n\r\n    /**\r\n     * Divides a matrix by a constant.\r\n     * \r\n     * Does not modify the original matrix.\r\n     * @param m The matrix.\r\n     * @param n The constant\r\n     * @returns The scaled matrix.\r\n     */\r\n    static divide = (m: Mat3, n: number) => Mat3.multiply(m, 1 / n);\r\n\r\n    /**\r\n     * Transposes a matrix.\r\n     * @param m The matrix.\r\n     * @returns The transposed matrix.\r\n     */\r\n    static transpose = (m: Mat3) => {\r\n        return new Mat3([\r\n            [m._m[0][0], m._m[1][0], m._m[2][0]],\r\n            [m._m[0][1], m._m[1][1], m._m[2][1]],\r\n            [m._m[0][2], m._m[1][2], m._m[2][2]]\r\n        ]);;\r\n    }\r\n\r\n    /**\r\n     * Inverts a matrix. If the matrix is not invertible, an error is thrown.\r\n     * \r\n     * Does not modify the original matrix.\r\n     * @param m The matrix.\r\n     * @returns The inverse matrix.\r\n     */\r\n    static inverse = (m: Mat3) => {\r\n        const det = m.determinant;\r\n        if (det === 0) {\r\n            console.error(`Matrix ${m._m} is not invertible`);\r\n            return m;\r\n        }\r\n        return Mat3.multiply(new Mat3([\r\n            [m.getCofactorDeterminant(0, 0), m.getCofactorDeterminant(1, 0), m.getCofactorDeterminant(2, 0)],\r\n            [m.getCofactorDeterminant(0, 1), m.getCofactorDeterminant(1, 1), m.getCofactorDeterminant(2, 1)],\r\n            [m.getCofactorDeterminant(0, 2), m.getCofactorDeterminant(1, 2), m.getCofactorDeterminant(2, 2)]\r\n        ]), 1 / det);\r\n    }\r\n\r\n    /**\r\n     * Constructs a translation matrix.\r\n     * @param v The translation vector.\r\n     * @returns The translation matrix.\r\n     */\r\n    static makeTranslation = (v: Vec2) => {\r\n        return Mat3.identity.set(0, 2, v.x).set(1, 2, v.y);\r\n    }\r\n\r\n    /**\r\n     * Constructs a rotation matrix.\r\n     * @param deg The rotation in degrees.\r\n     * @returns The rotation matrix.\r\n     */\r\n    static makeRotation = (deg: number) => {\r\n        const r = deg * Math.PI / 180;\r\n        return Mat3.identity\r\n            .set(0, 0, Math.cos(r)).set(0, 1, -Math.sin(r))\r\n            .set(1, 0, Math.sin(r)).set(1, 1, Math.cos(r));\r\n    }\r\n\r\n    /**\r\n     * Constructs a scaling matrix.\r\n     * @param v The scaling vector.\r\n     * @returns The scaling matrix.\r\n     */\r\n    static makeScaling = (v: Vec2) => {\r\n        return Mat3.identity.set(0, 0, v.x).set(1, 1, v.y);\r\n    }\r\n\r\n    /**\r\n     * Constructs a transformation matrix.\r\n     * @param t The translation vector.\r\n     * @param r The rotation in degrees.\r\n     * @param s The scaling vector.\r\n     * @returns The transformation matrix.\r\n     */\r\n    static makeTransformation = (t: Vec2, r: number, s: Vec2) => {\r\n        return Mat3.matrixMultiply(\r\n            Mat3.matrixMultiply(\r\n                Mat3.makeTranslation(t),\r\n                Mat3.makeRotation(r)\r\n            ), Mat3.makeScaling(s)\r\n        );\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport IDebugDrawable from './IDebugDrawable';\r\nimport Node from './Node';\r\nimport Bounds from '../structures/Bounds';\r\n\r\n/**\r\n * 32-bit bitmask used for collisions.\r\n */\r\nexport type Mask = number;\r\n\r\n/**\r\n * Base class for all collider nodes.\r\n * \r\n * A collider must have a parent PhysicsBody to detect collisions.\r\n */\r\nexport default abstract class Collider extends Node implements IDebugDrawable {\r\n    protected static readonly BOUNDS_PADDING = 10;\r\n\r\n    protected _bounds = Bounds.zero;\r\n    protected _restitution = 1;\r\n\r\n    /** The layers this body is part of. */\r\n    layers: Mask = 0x00000001;\r\n    /** The layers this body can interact with. */\r\n    filter: Mask = 0x00000001;\r\n\r\n    /** The globally positioned bounds of this collider. */\r\n    get bounds() { return this._bounds.copy(); }\r\n\r\n    /** \r\n     * The \"bounciness\" of this collider.\r\n     * \r\n     * A value of 0 is perfectly inelastic.\r\n     * A value of 1 is perfectly elastic.\r\n     * A value above 1 is energy generating.\r\n     */\r\n    get restitution() { return this._restitution; }\r\n    set restitution(value: number) { this._restitution = Math.max(value, 0); }\r\n\r\n    /**\r\n     * Regenerates the cached properties of the collider.\r\n     * \r\n     * Implementation defined by the collider subtype.\r\n     */\r\n    abstract regenerate(): void;\r\n\r\n    /**\r\n     * Determines if this collider can interact with another collider based on their layers.\r\n     * @param other The other collider.\r\n     * @returns Whether the colliders can interact.\r\n     */\r\n    canCollideWith(other: Collider) {\r\n        return ((other.layers & this.filter) !== 0);\r\n    }\r\n\r\n    onDebugDraw(context: CanvasRenderingContext2D): void {\r\n        // Draw bb\r\n        context.strokeStyle = \"#00ffff\";\r\n        context.strokeRect(\r\n            this._bounds.min.x,\r\n            this._bounds.min.y,\r\n            this._bounds.size.x,\r\n            this._bounds.size.y);\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\nimport Vec2 from './Vec2';\r\n\r\n/**\r\n * Representation of 2D bounds.\r\n */\r\nexport default class Bounds implements ICopyable, IEquatable {\r\n    /** The minimum components. */\r\n    min: Vec2 = Vec2.zero;\r\n    /** The maximum components. */\r\n    max: Vec2 = Vec2.zero;\r\n\r\n    constructor(min: Vec2, max: Vec2) {\r\n        this.min = min.copy();\r\n        this.max = max.copy();\r\n    }\r\n\r\n    copy = () => new Bounds(this.min, this.max);\r\n    equals = (other: Bounds) => this.min.equals(other.min) && this.max.equals(other.max);\r\n\r\n    /** The size of the bounds. */\r\n    get size() { return Vec2.subtract(this.max, this.min); }\r\n\r\n    /**\r\n     * Determines if a point exists inside this bounds.\r\n     * @param point The point.\r\n     * @returns Whether the point exists inside this bounds.\r\n     */\r\n    contains = (point: Vec2) => point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y;\r\n\r\n    /**\r\n     * Determines if this bounds overlaps with another bounds.\r\n     * @param other The other bounds.\r\n     * @returns Whether the bounds overlap.\r\n     */\r\n    overlaps = (other: Bounds) => this.min.x <= other.max.x && this.max.x >= other.min.x && this.max.y >= other.min.y && this.min.y <= other.max.y;\r\n\r\n    /** The zero bounds, [(0, 0), (0, 0)]. */\r\n    static get zero() { return new Bounds(Vec2.zero, Vec2.zero); }\r\n    /** The unit bounds, [(0, 0), (1, 1)]. */\r\n    static get unit() { return new Bounds(Vec2.zero, Vec2.one); }\r\n    /** The normalized bounds, [(-0.5, -0.5), (0.5, 0.5)]. */\r\n    static get norm() { return new Bounds(Vec2.multiply(Vec2.one, -0.5), Vec2.multiply(Vec2.one, 0.5)); }\r\n\r\n    /**\r\n     * Create bounds based on a set of vertices.\r\n     * @param vertices The vertices.\r\n     * @returns The bounds.\r\n     */\r\n    static fromVertices = (vertices: Vec2[]) => {\r\n        let b = new Bounds(Vec2.infinity, Vec2.negativeInfinity);\r\n\r\n        // Iterate all vertices\r\n        for (const vertex of vertices) {\r\n            if (vertex.x > b.max.x) b.max = new Vec2(vertex.x, b.max.y);\r\n            if (vertex.x < b.min.x) b.min = new Vec2(vertex.x, b.min.y);\r\n            if (vertex.y > b.max.y) b.max = new Vec2(b.max.x, vertex.y);\r\n            if (vertex.y < b.min.y) b.min = new Vec2(b.min.x, vertex.y);\r\n        }\r\n        return b;\r\n    };\r\n\r\n    /**\r\n     * Create bounds that envelop a set of bounds.\r\n     * @param boundses The set of bounds to envelop.\r\n     * @returns The bounds.\r\n     */\r\n    static makeEnvelop = (boundses: Bounds[],) => {\r\n        let b = new Bounds(Vec2.infinity, Vec2.negativeInfinity);\r\n\r\n        // Iterate all bounds\r\n        for (const bounds of boundses) {\r\n            if (bounds.max.x > b.max.x) b.max = new Vec2(bounds.max.x, b.max.y);\r\n            if (bounds.min.x < b.min.x) b.min = new Vec2(bounds.min.x, b.min.y);\r\n            if (bounds.max.y > b.max.y) b.max = new Vec2(b.max.x, bounds.max.y);\r\n            if (bounds.min.y < b.min.y) b.min = new Vec2(b.min.x, bounds.min.y);\r\n        }\r\n        return b;\r\n    };\r\n\r\n    /**\r\n     * Translates bounds.\r\n     * @param b The bounds.\r\n     * @param v The translation vector.\r\n     * @returns The translated bounds.\r\n     */\r\n    static translate = (b: Bounds, v: Vec2) => { return new Bounds(Vec2.add(b.min, v), Vec2.add(b.max, v)); };\r\n\r\n    /**\r\n     * Scales bounds.\r\n     * @param b The bounds.\r\n     * @param v The scale vector.\r\n     * @param origin The normalized origin to scale from.\r\n     * @returns The scaled bounds.\r\n     */\r\n    static scale = (b: Bounds, v: Vec2, origin: Vec2 = Vec2.multiply(Vec2.one, 0.5)) => {\r\n        const o = Vec2.lerpComponents(b.min, b.max, origin);\r\n        return new Bounds(\r\n            Vec2.add(Vec2.multiplyComponents(Vec2.add(b.min, Vec2.multiply(o, -1)), v), o),\r\n            Vec2.add(Vec2.multiplyComponents(Vec2.add(b.max, Vec2.multiply(o, -1)), v), o)\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Shifts bounds such that its origin is at a given position.\r\n     * @param b The bounds.\r\n     * @param pos The position.\r\n     * @param origin The normalized origin of the bounds.\r\n     * @returns The shifted bounds.\r\n     */\r\n    static shift = (b: Bounds, pos: Vec2, origin: Vec2 = Vec2.multiply(Vec2.one, 0.5)) => {\r\n        const o = Vec2.lerpComponents(b.min, b.max, origin);\r\n        return Bounds.translate(b, Vec2.subtract(pos, o));\r\n    };\r\n\r\n    /**\r\n     * Extends bounds by a vector.\r\n     * @param b The bounds.\r\n     * @param v The extension vector.\r\n     * @returns The extended bounds.\r\n     */\r\n    static extend = (b: Bounds, v: Vec2) => {\r\n        if (v.x > 0) {\r\n            b.max = new Vec2(b.max.x + v.x, b.max.y);\r\n        } else {\r\n            b.min = new Vec2(b.min.x + v.x, b.min.y);\r\n        }\r\n        if (v.y > 0) {\r\n            b.max = new Vec2(b.max.x, b.max.y + v.y);\r\n        } else {\r\n            b.min = new Vec2(b.min.x, b.min.y + v.y);\r\n        }\r\n        return b;\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * Static class for moving the viewport in the world space.\r\n */\r\nexport default class Camera {\r\n    /**\r\n     * The position of the camera.\r\n     */\r\n    static position: Vec2 = Vec2.zero;\r\n\r\n    /**\r\n     * The rotation of the camera.\r\n     */\r\n    static rotation: number = 0;\r\n\r\n    /**\r\n     * The scale of the camera.\r\n     */\r\n    static scale: Vec2 = Vec2.one;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Camera from './Camera';\r\nimport Mat3 from '../structures/Mat3';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * Static class for input handling.\r\n */\r\nexport default class Input {\r\n    private static singleton: Input | null = null;\r\n    private static canvas: HTMLCanvasElement | null = null;\r\n    private static keyStates: Set<string> = new Set<string>();\r\n    private static keyTransits: Set<string> = new Set<string>();\r\n    private static mouseStates: Set<number> = new Set<number>();\r\n    private static mouseTransits: Set<number> = new Set<number>();\r\n    private static mousePos: Vec2 = Vec2.zero;\r\n\r\n    constructor(canvas: HTMLCanvasElement) {\r\n        if (Input.singleton) {\r\n            console.warn(\"Input is used as a static class, do not create additional objects of Input\");\r\n            return;\r\n        }\r\n        Input.singleton = this;\r\n\r\n        // Register canvas events\r\n        Input.canvas = canvas;\r\n        canvas.onmousedown = (ev) => {\r\n            const b = ev.button;\r\n            Input.mouseStates.add(b);\r\n            Input.mouseTransits.add(b);\r\n        };\r\n        canvas.onmouseup = canvas.onmouseleave = (ev) => {\r\n            const b = ev.button;\r\n            Input.mouseStates.delete(b);\r\n            Input.mouseTransits.add(b);\r\n        };\r\n        canvas.onmousemove = (ev) => {\r\n            Input.mousePos = new Vec2(ev.offsetX, ev.offsetY);\r\n        };\r\n\r\n        // Register window events\r\n        window.onkeydown = (ev) => {\r\n            const c = ev.code;\r\n            if (!ev.repeat) {\r\n                Input.keyStates.add(c);\r\n                Input.keyTransits.add(c);\r\n            }\r\n            ev.preventDefault();\r\n        };\r\n        window.onkeyup = (ev) => {\r\n            const c = ev.code;\r\n            Input.keyStates.delete(c);\r\n            Input.keyTransits.add(c);\r\n            ev.preventDefault();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Clears all internal flags at the end of the frame.\r\n     * \r\n     * Called by `Petrallengine.create`.\r\n     */\r\n    endFrame() {\r\n        for (let i of Input.keyTransits.keys()) {\r\n            Input.keyTransits.delete(i);\r\n        }\r\n        for (let i of Input.mouseTransits.keys()) {\r\n            Input.mouseTransits.delete(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns whether a keyboard key is down.\r\n     * @param keyCode The code of the key.\r\n     * @returns Whether the key is down.\r\n     */\r\n    static isKey(keyCode: string) {\r\n        return Input.keyStates.has(keyCode);\r\n    }\r\n\r\n    /**\r\n     * Returns whether a keyboard key was pressed this frame.\r\n     * @param keyCode The code of the key.\r\n     * @returns Whether the key was pressed this frame.\r\n     */\r\n    static isKeyPressed(keyCode: string) {\r\n        return Input.keyTransits.has(keyCode) && Input.isKey(keyCode);\r\n    }\r\n\r\n    /**\r\n     * Returns whether a keyboard key was released this frame.\r\n     * @param keyCode The code of the key.\r\n     * @returns Whether the key was released this frame.\r\n     */\r\n    static isKeyReleased(keyCode: string) {\r\n        return Input.keyTransits.has(keyCode) && !Input.isKey(keyCode);\r\n    }\r\n\r\n    /**\r\n     * Returns whether a mouse button is down.\r\n     * @param button The mouse button.\r\n     * @returns Whether the mouse button is down.\r\n     */\r\n    static isMouse(button: number = 0) {\r\n        return Input.mouseStates.has(button);\r\n    }\r\n\r\n    /**\r\n     * Returns whether a mouse button was pressed this frame.\r\n     * @param button The mouse button.\r\n     * @returns Whether the mouse button was pressed this frame.\r\n     */\r\n    static isMousePressed(button: number = 0) {\r\n        return Input.mouseTransits.has(button) && Input.isMouse(button);\r\n    }\r\n\r\n    /**\r\n     * Returns whether a mouse button was released this frame.\r\n     * @param button The mouse button.\r\n     * @returns Whether the mouse button was released this frame.\r\n     */\r\n    static isMouseReleased(button: number = 0) {\r\n        return Input.mouseTransits.has(button) && !Input.isMouse(button);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the mouse in the canvas.\r\n     * @returns The position of the mouse in the canvas.\r\n     */\r\n    static get mousePosition() {\r\n        return Input.mousePos;\r\n    }\r\n\r\n    /**\r\n     * Returns the normalized position of the mouse in the canvas.\r\n     * @returns The normalized position of the mouse in the canvas.\r\n     */\r\n    static get mousePositionNormalized() {\r\n        return Vec2.multiplyComponents(Input.mousePos, new Vec2(1 / Input.canvas!.width, 1 / Input.canvas!.height));\r\n    }\r\n\r\n    /**\r\n     * Returns the position on the canvas of a normalized canvas position.\r\n     * @returns The position on the canvas of a normalized canvas position.\r\n     */\r\n    static normalizedToCanvas(normalizedPos: Vec2) {\r\n        return Vec2.multiplyComponents(normalizedPos, new Vec2(Input.canvas!.width, Input.canvas!.height));\r\n    }\r\n\r\n    /**\r\n     * Returns the normalized position of a canvas position.\r\n     * @returns The normalized position of a canvas position.\r\n     */\r\n    static canvasToNormalized(canvasPos: Vec2) {\r\n        return Vec2.multiplyComponents(canvasPos, new Vec2(1 / Input.canvas!.width, 1 / Input.canvas!.height));\r\n    }\r\n\r\n    /**\r\n     * Returns the position on the canvas of a world position.\r\n     * @returns The position on the canvas of a world position.\r\n     */\r\n    static worldToCanvas(worldPos: Vec2) {\r\n        return Vec2.add(\r\n            Vec2.transform(\r\n                Mat3.makeTransformation(Vec2.multiply(Camera.position, -1), -Camera.rotation, Camera.scale),\r\n                worldPos),\r\n            Vec2.multiply(Vec2.fromObjWH(Input.canvas!), 0.5)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the position in the world of a canvas position.\r\n     * @returns The position in the world of a canvas position.\r\n     */\r\n    static canvasToWorld(canvasPos: Vec2) {\r\n        return Vec2.transform(\r\n            Mat3.inverse(Mat3.makeTransformation(Vec2.multiply(Camera.position, -1), -Camera.rotation, Camera.scale)),\r\n            Vec2.add(canvasPos, Vec2.multiply(Vec2.fromObjWH(Input.canvas!), -0.5))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the normalized position on the canvas of a world position.\r\n     * @returns The normalized position on the canvas of a world position.\r\n     */\r\n    static worldToNormalized(worldPos: Vec2) {\r\n        return Input.canvasToNormalized(Input.worldToCanvas(worldPos));\r\n    }\r\n\r\n    /**\r\n     * Returns position in the world of a normalized canvas position.\r\n     * @returns The position in the world of a normalized canvas position.\r\n     */\r\n    static normalizedToWorld(normalizedPos: Vec2) {\r\n        return Input.canvasToWorld(Input.normalizedToCanvas(normalizedPos));\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport { Snowflake } from '../Snowflake';\r\nimport Game from '../Game';\r\nimport Body from '../nodes/Body';\r\nimport CircleCollider from '../nodes/CircleCollider';\r\nimport Collider from '../nodes/Collider';\r\nimport ConvexCollider from '../nodes/ConvexCollider';\r\nimport LineCollider from '../nodes/LineCollider'\r\nimport RigidBody from '../nodes/RigidBody';\r\nimport Bounds from '../structures/Bounds';\r\nimport ICopyable from '../structures/ICopyable';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\nclass RBVec implements ICopyable {\r\n    /** The positional component. */\r\n    pos: Vec2 = Vec2.zero;\r\n    /** The rotational component. */\r\n    rot: number = 0;\r\n\r\n    constructor(positional: Vec2, rotational: number) {\r\n        this.pos = positional.copy();\r\n        this.rot = rotational;\r\n    }\r\n\r\n    copy = () => new RBVec(this.pos, this.rot);\r\n\r\n    /** The zero vector. */\r\n    static get zero() { return new RBVec(Vec2.zero, 0); }\r\n}\r\n\r\ninterface CollisionInput {\r\n    /** Position of the collider. */\r\n    position: Vec2;\r\n    /** Velocity of the collider. */\r\n    velocity: Vec2;\r\n}\r\ninterface CircleInput extends CollisionInput {\r\n    /** Radius of the collider. */\r\n    radius: number;\r\n}\r\ninterface LineSegmentInput extends CollisionInput {\r\n    /** Direction offset of the collider. */\r\n    direction: Vec2;\r\n}\r\n\r\ninterface CollisionOutput {\r\n    /** The depth of penetration if already intersecting this frame. */\r\n    penetrationDepth: number;\r\n    /** Whether colliders will intersect this frame. */\r\n    willIntersect: boolean;\r\n    /** Time to intersection. */\r\n    intersectTime: number;\r\n    /** Intersection point of first collider in world coordinates. */\r\n    intersectPos1: Vec2;\r\n    /** Intersection point of second collider in world coordinates. */\r\n    intersectPos2: Vec2;\r\n    /** Contact point of the colliders in world coordinates. */\r\n    contactPos: Vec2;\r\n    /** Normal to the contact point of the colliders in world coordinates. */\r\n    contactNormal: Vec2;\r\n}\r\n\r\ntype SnowflakePair = Snowflake;\r\nfunction makeSnowflakePair(id1: Snowflake, id2: Snowflake) {\r\n    if (id1 < id2)\r\n        return id1 + '|' + id2;\r\n    return id2 + '|' + id1;\r\n}\r\nfunction breakSnowflakePair(pair: SnowflakePair): [Snowflake, Snowflake] {\r\n    const items = pair.split('|');\r\n    return [items[0], items[1]];\r\n}\r\n\r\n/**\r\n * Static class for physics and collisions.\r\n */\r\nexport default class Physics {\r\n    private static readonly PENETRATION_IMPULSE_STRENGTH = 100;\r\n    private static singleton: Physics | null = null;\r\n    private static bodies: Map<Snowflake, Body> = new Map<Snowflake, Body>();\r\n    private static colliders: Map<Snowflake, Collider> = new Map<Snowflake, Collider>();\r\n    private static bodyColliders: Map<Snowflake, Set<Snowflake>> = new Map<Snowflake, Set<Snowflake>>();\r\n    private static colliderBodies: Map<Snowflake, Snowflake> = new Map<Snowflake, Snowflake>();\r\n    private static pairsCollided: Set<SnowflakePair> = new Set<SnowflakePair>();\r\n\r\n    // DEBUG\r\n    debugContacts: Map<Vec2, number> = new Map<Vec2, number>();\r\n\r\n    constructor() {\r\n        if (Physics.singleton) {\r\n            console.warn(\"Physics is used as a static class, do not create additional objects of Physics\");\r\n            return;\r\n        }\r\n        Physics.singleton = this;\r\n    }\r\n\r\n    tick() {\r\n        // --- DYNAMICS ---\r\n\r\n        for (const [_, body] of Physics.bodies) {\r\n            if (!(body instanceof RigidBody))\r\n                continue;\r\n\r\n            // Gravity\r\n            body.velocity = Vec2.add(body.velocity, Vec2.multiply(body.gravity, Game.deltaTime / body.mass));\r\n\r\n            // Drag\r\n            body.velocity = Vec2.divide(body.velocity, body.drag + 1);\r\n        }\r\n\r\n        // --- COLLISION DETECTION ---\r\n\r\n        type Collision = [Collider, Collider, CollisionOutput];\r\n        let collisions: Collision[] = []; // all collisions this iteration\r\n        let bodyCollisionCount: Map<Body, number> = new Map<Body, number>(); // number of collisions per body this iteration\r\n        let bodyPairsCalled: Set<SnowflakePair> = new Set<SnowflakePair>(); // pairs of bodies triggered this iteration\r\n        const collideBodies = (c1: Collider, c2: Collider, col: CollisionOutput) => {\r\n            const b1 = Physics.bodies.get(Physics.colliderBodies.get(c1.id)!)!;\r\n            const b2 = Physics.bodies.get(Physics.colliderBodies.get(c2.id)!)!;\r\n            const pair = makeSnowflakePair(b1.id, b2.id);\r\n\r\n            if (!bodyPairsCalled.has(pair)) {\r\n                // Call collision enter callback\r\n                if (!Physics.pairsCollided.has(pair)) {\r\n                    Physics.pairsCollided.add(pair);\r\n                    b1.onCollisionEnter?.call(b1, b2);\r\n                    b2.onCollisionEnter?.call(b2, b1);\r\n                }\r\n\r\n                // Call collision update callback\r\n                b1.onCollisionUpdate?.call(b1, b2);\r\n                b2.onCollisionUpdate?.call(b2, b1);\r\n\r\n                // Mark this pair as being called this frame\r\n                bodyPairsCalled.add(pair);\r\n            }\r\n\r\n            // Register collision between bodies for resolution\r\n            bodyCollisionCount.set(b1, (bodyCollisionCount.get(b1) ?? 0) + 1);\r\n            bodyCollisionCount.set(b2, (bodyCollisionCount.get(b2) ?? 0) + 1);\r\n            collisions.push([c1, c2, col]);\r\n\r\n            // DEBUG\r\n            if (col.willIntersect) {\r\n                this.debugContacts.set(col.contactPos, 0.1);\r\n            }\r\n        }\r\n\r\n        // Get colliders as array\r\n        let colliders: Collider[] = Array.from(Physics.colliders.values());\r\n\r\n        // Sort by min x\r\n        colliders.sort((c1, c2) => c1.bounds.min.x - c2.bounds.min.x);\r\n\r\n        // Iterate all colliders\r\n        for (let i = 0; i < colliders.length; i++) {\r\n            const ci = colliders[i];\r\n            ci.globalTransform;\r\n            ci.regenerate();\r\n            const bi = Physics.bodies.get(Physics.colliderBodies.get(ci.id)!)!;\r\n            for (let j = i + 1; j < colliders.length; j++) {\r\n                const cj = colliders[j];\r\n                ci.globalTransform;\r\n                cj.regenerate();\r\n                const bj = Physics.bodies.get(Physics.colliderBodies.get(cj.id)!)!;\r\n\r\n                // Same body\r\n                if (bi.id === bj.id) {\r\n                    continue;\r\n                }\r\n\r\n                // --- BROAD PHASE ---\r\n\r\n                // Non-intersecting layers\r\n                if (!ci.canCollideWith(cj)) {\r\n                    continue;\r\n                }\r\n\r\n                // Extend bounds\r\n                const bndi = Bounds.extend(ci.bounds, Vec2.multiply(bi.velocity, Game.deltaTime));\r\n                const bndj = Bounds.extend(cj.bounds, Vec2.multiply(bj.velocity, Game.deltaTime));\r\n\r\n                // X limits\r\n                if (bndj.min.x > bndi.max.x) {\r\n                    break;\r\n                }\r\n\r\n                // Y overlap\r\n                if (bndi.max.y < bndj.min.y || bndi.min.y > bndj.max.y) {\r\n                    continue;\r\n                }\r\n\r\n                // BB overlap\r\n                if (!bndi.overlaps(bndj)) {\r\n                    continue;\r\n                }\r\n\r\n                // --- NARROW PHASE ---\r\n\r\n                if (ci instanceof CircleCollider && cj instanceof CircleCollider) {\r\n                    // Circle-circle\r\n                    const col = Physics.circleCircleIntersection({\r\n                        position: ci.globalPosition,\r\n                        velocity: Vec2.multiply(bi.velocity, Game.deltaTime),\r\n                        radius: ci.globalRadius\r\n                    }, {\r\n                        position: cj.globalPosition,\r\n                        velocity: Vec2.multiply(bj.velocity, Game.deltaTime),\r\n                        radius: cj.globalRadius\r\n                    });\r\n                    if (col.penetrationDepth > 0 || col.willIntersect) {\r\n                        collideBodies(ci, cj, col);\r\n                    }\r\n                    continue;\r\n                }\r\n                else if ((ci instanceof CircleCollider && cj instanceof LineCollider) ||\r\n                    ci instanceof LineCollider && cj instanceof CircleCollider) {\r\n                    // Circle-line\r\n                    const ccircle = (ci instanceof CircleCollider ? ci : cj) as CircleCollider;\r\n                    const cline = (ci instanceof LineCollider ? ci : cj) as LineCollider;\r\n                    const bcircle = (ccircle == ci) ? bi : bj;\r\n                    const bline = (cline == ci) ? bi : bj;\r\n                    const col = Physics.circleLineSegmentIntersection({\r\n                        position: ccircle.globalPosition,\r\n                        velocity: Vec2.multiply(bcircle.velocity, Game.deltaTime),\r\n                        radius: ccircle.globalRadius\r\n                    }, {\r\n                        position: cline.globalPosition,\r\n                        velocity: Vec2.multiply(bline.velocity, Game.deltaTime),\r\n                        direction: cline.globalDirection\r\n                    });\r\n                    if (col.penetrationDepth > 0 || col.willIntersect) {\r\n                        collideBodies(ccircle, cline, col);\r\n                    }\r\n                    continue;\r\n                }\r\n                else if (ci instanceof ConvexCollider && cj instanceof ConvexCollider) {\r\n                    // Polygon-polygon\r\n                    // TODO\r\n                    continue;\r\n                }\r\n                else if (\r\n                    (ci instanceof CircleCollider && cj instanceof ConvexCollider) ||\r\n                    (ci instanceof ConvexCollider && cj instanceof CircleCollider)) {\r\n                    // Circle-polygon\r\n                    // TODO\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Clear uncalled pairs\r\n        for (const pair of Physics.pairsCollided.values()) {\r\n            const [b1id, b2id] = breakSnowflakePair(pair);\r\n            if (bodyPairsCalled.has(pair)) {\r\n                continue;\r\n            }\r\n            const [b1, b2] = [Physics.bodies.get(b1id)!, Physics.bodies.get(b2id)!];\r\n            Physics.pairsCollided.delete(pair);\r\n            b1.onCollisionExit?.call(b1, b2);\r\n            b2.onCollisionExit?.call(b2, b1);\r\n        }\r\n\r\n        // --- COLLISION RESPONSE ---\r\n\r\n        // Store next calculated values for each body\r\n        type Cached = { pos: Vec2, vel: Vec2 };\r\n        let cached: Map<Body, Cached> = new Map<Body, Cached>();\r\n        for (const b of Physics.bodies.values()) {\r\n            cached.set(b, {\r\n                pos: b.globalPosition,\r\n                vel: b.velocity\r\n            });\r\n        }\r\n\r\n        // Solve collisions\r\n        for (const collision of collisions) {\r\n            const [c1, c2, col] = collision;\r\n            const b1 = Physics.bodies.get(Physics.colliderBodies.get(c1.id)!)!;\r\n            const b2 = Physics.bodies.get(Physics.colliderBodies.get(c2.id)!)!;\r\n            let b1cache = cached.get(b1)!;\r\n            let b2cache = cached.get(b2)!;\r\n\r\n            // Only respond if both are RBs\r\n            if (b1 instanceof RigidBody && b2 instanceof RigidBody) {\r\n                // Mass splitting\r\n                let [m1, m2] = [b1.mass / (bodyCollisionCount.get(b1) ?? 1), b2.mass / (bodyCollisionCount.get(b2) ?? 1)];\r\n\r\n                // Infinite mass case\r\n                if (b1.mass === Infinity && b2.mass === Infinity)\r\n                    continue;\r\n\r\n                const w = Physics.massToWeights(m1, m2);\r\n\r\n                // Impulse response\r\n                if (col.willIntersect) {\r\n                    const restitution = (c1.restitution + c2.restitution) / 2;\r\n\r\n                    // Magnitude of velocity in direction of normal\r\n                    const [a1, a2] = [\r\n                        Vec2.dot(Vec2.multiply(b1.velocity, Game.deltaTime), col.contactNormal),\r\n                        Vec2.dot(Vec2.multiply(b2.velocity, Game.deltaTime), col.contactNormal)];\r\n\r\n                    // Get calculated reflected velocities and position\r\n                    const reflVel1 = Vec2.multiply(Vec2.add(Vec2.multiply(b1.velocity, Game.deltaTime), Vec2.multiply(col.contactNormal, 2 * (a2 - a1) * w[0])), restitution);\r\n                    const reflVel2 = Vec2.multiply(Vec2.add(Vec2.multiply(b2.velocity, Game.deltaTime), Vec2.multiply(col.contactNormal, 2 * (a1 - a2) * w[1])), restitution);\r\n                    const reflPos1 = Vec2.add(col.intersectPos1, Vec2.multiply(reflVel1, (1 - col.intersectTime)));\r\n                    const reflPos2 = Vec2.add(col.intersectPos2, Vec2.multiply(reflVel2, (1 - col.intersectTime)));\r\n\r\n                    // Offset of collider from body\r\n                    const c1Off = Vec2.subtract(c1.globalPosition, b1.globalPosition);\r\n                    const c2Off = Vec2.subtract(c2.globalPosition, b2.globalPosition);\r\n\r\n                    // Accumulate deltas\r\n                    let dp1 = Vec2.subtract(Vec2.subtract(reflPos1, c1Off), b1cache.pos);\r\n                    let dp2 = Vec2.subtract(Vec2.subtract(reflPos2, c2Off), b2cache.pos);\r\n                    let dv1 = Vec2.subtract(Vec2.divide(reflVel1, Game.deltaTime), b1cache.vel);\r\n                    let dv2 = Vec2.subtract(Vec2.divide(reflVel2, Game.deltaTime), b2cache.vel);\r\n\r\n                    b1cache.pos = Vec2.add(b1cache.pos, dp1);\r\n                    b2cache.pos = Vec2.add(b2cache.pos, dp2);\r\n                    b1cache.vel = Vec2.add(b1cache.vel, dv1);\r\n                    b2cache.vel = Vec2.add(b2cache.vel, dv2);\r\n                }\r\n\r\n                // Penetration response\r\n                if (col.penetrationDepth > 0) {\r\n                    b1cache.vel = Vec2.add(b1cache.vel, Vec2.multiply(col.contactNormal, Physics.PENETRATION_IMPULSE_STRENGTH * col.penetrationDepth * w[0]));\r\n                    b2cache.vel = Vec2.add(b2cache.vel, Vec2.multiply(col.contactNormal, -Physics.PENETRATION_IMPULSE_STRENGTH * col.penetrationDepth * w[1]));\r\n                }\r\n\r\n                // Normal response\r\n                b1cache.pos = Vec2.add(b1cache.pos, Vec2.multiply(col.contactNormal, (1 + col.penetrationDepth) * w[0] * Game.deltaTime));\r\n                b2cache.pos = Vec2.add(b2cache.pos, Vec2.multiply(col.contactNormal, -(1 + col.penetrationDepth) * w[1] * Game.deltaTime));\r\n            }\r\n        }\r\n\r\n        // --- PHYSICS RESOLUTION ---\r\n\r\n        for (const [body, next] of cached) {\r\n            body.velocity = next.vel;\r\n            body.globalPosition = Vec2.add(next.pos, Vec2.multiply(next.vel, Game.deltaTime));\r\n        }\r\n    }\r\n\r\n    static registerBody(body: Body) {\r\n        if (Physics.bodies.has(body.id) || Physics.bodyColliders.has(body.id)) {\r\n            console.error(`Body #${body.id} already registered in physics system`);\r\n            return;\r\n        }\r\n        Physics.bodies.set(body.id, body);\r\n        Physics.bodyColliders.set(body.id, new Set<Snowflake>);\r\n    }\r\n\r\n    static registerCollider(collider: Collider, owner: Body) {\r\n        if (Physics.colliders.has(collider.id) || Physics.colliderBodies.has(collider.id)) {\r\n            console.error(`Collider #${owner.id} already registered in physics system`);\r\n            return;\r\n        }\r\n        if (!Physics.bodies.has(owner.id)) {\r\n            console.error(`Body #${owner.id} not registered in physics system`);\r\n            return;\r\n        }\r\n        if (Physics.bodyColliders.get(owner.id)?.has(collider.id) || Physics.colliderBodies.has(collider.id)) {\r\n            console.warn(`Collider #${collider.id} already registered with body #${Physics.colliderBodies.get(collider.id)} in physics system`);\r\n            return;\r\n        }\r\n        Physics.colliders.set(collider.id, collider);\r\n        Physics.colliderBodies.set(collider.id, owner.id);\r\n        Physics.bodyColliders.get(owner.id)?.add(collider.id);\r\n    }\r\n\r\n    private static circleLineSegmentIntersection(c1: CircleInput, c2: LineSegmentInput) {\r\n        let output: CollisionOutput = {\r\n            penetrationDepth: 0,\r\n            willIntersect: false,\r\n            intersectTime: 0,\r\n            intersectPos1: Vec2.zero,\r\n            intersectPos2: Vec2.zero,\r\n            contactPos: Vec2.zero,\r\n            contactNormal: Vec2.zero,\r\n        };\r\n\r\n        // Line properties\r\n        const lineStart = Vec2.subtract(c2.position, c2.direction);\r\n        const lineMid = c2.position.copy();\r\n        const lineEnd = Vec2.add(c2.position, c2.direction);\r\n        const lineDirNorm = c2.direction.normalized;\r\n        const lineNormal = c2.direction.normal.normalized;\r\n\r\n        // Relative vel of 1 from 2\r\n        const relVel = Vec2.subtract(c1.velocity, c2.velocity);\r\n\r\n        // Parallel distance along line\r\n        const d = Vec2.dot(Vec2.subtract(c1.position, c2.position), lineDirNorm);\r\n\r\n        // Closest point on line\r\n        const cpline = Vec2.add(c2.position, Vec2.multiply(lineDirNorm, Math.clamp(d, -c2.direction.length, c2.direction.length)));\r\n        output.contactNormal = Vec2.subtract(c1.position, cpline).normalized;\r\n        output.penetrationDepth = Math.max(c1.radius - Vec2.subtract(c1.position, cpline).length, 0);\r\n\r\n        // Zero relative velocity\r\n        if (relVel.sqrLength === 0) {\r\n            return output;\r\n        }\r\n\r\n        function lineEdgeCase(withinBothLines: boolean) {\r\n            // Relative vel normal\r\n            const relVelN = relVel.normal.normalized;\r\n\r\n            let closer: Vec2 = lineEnd;\r\n            let dist: number = 0;\r\n\r\n            if (withinBothLines) {\r\n                // Closer to start\r\n                if (Vec2.dot(Vec2.subtract(c1.position, lineMid), c2.direction) < 0) {\r\n                    closer = lineStart;\r\n                }\r\n                // Closer to end\r\n                else {\r\n                    closer = lineEnd;\r\n                }\r\n\r\n                dist = Vec2.dot(Vec2.subtract(closer, c1.position), relVelN);\r\n            }\r\n            else {\r\n                // Perpendicular distance to start, end\r\n                const dStart = Vec2.dot(Vec2.subtract(lineStart, c1.position), relVelN);\r\n                const dEnd = Vec2.dot(Vec2.subtract(lineEnd, c1.position), relVelN);\r\n                const dStartAbs = Math.abs(dStart);\r\n                const dEndAbs = Math.abs(dEnd);\r\n\r\n                dist = dEnd;\r\n\r\n                // No collision\r\n                if (dStartAbs > c1.radius && dEndAbs > c1.radius) {\r\n                    return output;\r\n                }\r\n                // Two possible collisions\r\n                else if (dStartAbs <= c1.radius && dEndAbs <= c1.radius) {\r\n                    // V distance to start, end\r\n                    const m0 = Vec2.dot(Vec2.subtract(lineStart, c1.position), relVel);\r\n                    const m1 = Vec2.dot(Vec2.subtract(lineEnd, c1.position), relVel);\r\n                    const m0Abs = Math.abs(m0);\r\n                    const m1Abs = Math.abs(m1);\r\n\r\n                    // Closer to start\r\n                    if (m0Abs < m1Abs) {\r\n                        closer = lineStart;\r\n                        dist = dStart;\r\n                    }\r\n                }\r\n                // Start possible collision only\r\n                else if (dStartAbs <= c1.radius) {\r\n                    closer = lineStart;\r\n                    dist = dStart;\r\n                }\r\n                // Else end possible collision only\r\n            }\r\n\r\n            // Delta from start to CPA\r\n            const m = Vec2.dot(Vec2.subtract(closer, c1.position), relVel.normalized);\r\n            if (m <= 0)\r\n                return;\r\n\r\n            // Delta from collision pt to CPA\r\n            const s = Math.sqrt(c1.radius * c1.radius - dist * dist);\r\n            if (Math.abs(dist) > c1.radius)\r\n                return;\r\n\r\n            // Time to intersect\r\n            const it = (m - s) / relVel.length;\r\n\r\n            if (it >= 0 && it <= 1) {\r\n                output.willIntersect = true;\r\n                output.intersectTime = it;\r\n                output.intersectPos1 = Vec2.add(c1.position, Vec2.multiply(c1.velocity, output.intersectTime));\r\n                output.intersectPos2 = Vec2.add(c2.position, Vec2.multiply(c2.velocity, output.intersectTime));\r\n                output.contactPos = closer.copy();\r\n            }\r\n        }\r\n\r\n        // Signed distance of circle from line segment\r\n        const sd = Vec2.dot(lineNormal, Vec2.subtract(c1.position, c2.position));\r\n        if (sd > -c1.radius && sd < c1.radius) {\r\n            // Circle between distant lines\r\n            lineEdgeCase(true);\r\n        }\r\n        else {\r\n            let extrudeFn = (pos: Vec2) => pos.copy();\r\n            let itFn = () => -1;\r\n            let contactFn = (ipos1: Vec2) => ipos1.copy();\r\n\r\n            // Circle in inner half plane opposite direction of normal\r\n            if (sd <= -c1.radius) {\r\n                extrudeFn = (pos: Vec2) => Vec2.subtract(pos, Vec2.multiply(lineNormal, c1.radius));\r\n                itFn = () => -(sd + c1.radius) / Vec2.dot(lineNormal, relVel);\r\n                contactFn = (ipos1: Vec2) => Vec2.add(ipos1, Vec2.multiply(lineNormal, c1.radius));\r\n            }\r\n            // Circle in outer half plane in direction of normal\r\n            else if (sd >= c1.radius) {\r\n                extrudeFn = (pos: Vec2) => Vec2.add(pos, Vec2.multiply(lineNormal, c1.radius));\r\n                itFn = () => -(sd - c1.radius) / Vec2.dot(lineNormal, relVel);\r\n                contactFn = (ipos1: Vec2) => Vec2.subtract(ipos1, Vec2.multiply(lineNormal, c1.radius));\r\n            }\r\n\r\n            // Extrude points\r\n            const pStart = extrudeFn(lineStart);\r\n            const pEnd = extrudeFn(lineEnd);\r\n\r\n            // Moving into segment\r\n            if (Vec2.dot(relVel.normal, Vec2.subtract(pStart, c1.position))\r\n                * Vec2.dot(relVel.normal, Vec2.subtract(pEnd, c1.position)) < 0) {\r\n                // Perpendicular distance / perpendicular velocity\r\n                // = Time to intersect\r\n                const it = itFn();\r\n\r\n                if (it >= 0 && it <= 1) {\r\n                    output.willIntersect = true;\r\n                    output.intersectTime = it;\r\n                    output.intersectPos1 = Vec2.add(c1.position, Vec2.multiply(c1.velocity, output.intersectTime));\r\n                    output.intersectPos2 = Vec2.add(c2.position, Vec2.multiply(c2.velocity, output.intersectTime));\r\n                    output.contactPos = contactFn(output.intersectPos1);\r\n                }\r\n            }\r\n            // Moving out of segment\r\n            else {\r\n                lineEdgeCase(false);\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n    private static circleCircleIntersection(c1: CircleInput, c2: CircleInput) {\r\n        let output: CollisionOutput = {\r\n            penetrationDepth: 0,\r\n            willIntersect: false,\r\n            intersectTime: 0,\r\n            intersectPos1: Vec2.zero,\r\n            intersectPos2: Vec2.zero,\r\n            contactPos: Vec2.zero,\r\n            contactNormal: Vec2.subtract(c1.position, c2.position).normalized,\r\n        };\r\n\r\n        // Relative circle radius\r\n        const relCircleRadius = c1.radius + c2.radius;\r\n\r\n        // Relative position of 1 from 2\r\n        const relPos = Vec2.subtract(c1.position, c2.position);\r\n        output.penetrationDepth = Math.max(relCircleRadius - relPos.length, 0);\r\n\r\n        // Relative vel of 1 from 2\r\n        const relVel = Vec2.subtract(c1.velocity, c2.velocity);\r\n\r\n        // Zero relative velocity\r\n        if (relVel.sqrLength === 0) {\r\n            return output;\r\n        }\r\n\r\n        // Convert to ray-circle problem\r\n        const relRayPos = c1.position.copy();\r\n        const relRayVel = relVel.copy();\r\n        const relCirclePos = c2.position.copy();\r\n\r\n        // Distance squared\r\n        const distSqr = Vec2.subtract(relRayPos, relCirclePos).sqrLength;\r\n\r\n        // Ray length\r\n        const rl = relRayVel.length;\r\n\r\n        // Delta from start to CPA\r\n        const m = Vec2.dot(Vec2.subtract(relCirclePos, relRayPos), relRayVel.normalized);\r\n\r\n        // CPA\r\n        const nSqr = distSqr - m * m;\r\n        if (nSqr > relCircleRadius * relCircleRadius)\r\n            return output;\r\n\r\n        // Delta from collision point to CPA\r\n        const s = Math.sqrt(relCircleRadius * relCircleRadius - nSqr);\r\n\r\n        // Time to intersect\r\n        const it = (m - s) / rl;\r\n        if (it >= 0 && it <= 1) {\r\n            output.willIntersect = true;\r\n            output.intersectTime = it;\r\n            output.intersectPos1 = Vec2.add(c1.position, Vec2.multiply(c1.velocity, output.intersectTime));\r\n            output.intersectPos2 = Vec2.add(c2.position, Vec2.multiply(c2.velocity, output.intersectTime));\r\n            output.contactPos = Vec2.lerp(output.intersectPos1, output.intersectPos2, c1.radius / (c1.radius + c2.radius));\r\n            output.contactNormal = Vec2.subtract(output.intersectPos1, output.intersectPos2).normalized;\r\n        }\r\n        return output;\r\n    }\r\n\r\n    private static massToWeights(m1: number, m2: number) {\r\n        return [\r\n            m2 < Infinity ? (m2 / (m1 + m2)) : 1,\r\n            m1 < Infinity ? (m1 / (m1 + m2)) : 1\r\n        ];\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Collider from './Collider';\r\nimport Bounds from '../structures/Bounds';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * A node that has a circle collider shape.\r\n */\r\nexport default class CircleCollider extends Collider {\r\n    private _radius: number = 1;\r\n\r\n    /** The radius of the circle. */\r\n    get radius() { return this._radius; }\r\n    set radius(value: number) { this._radius = Math.max(value, 0); }\r\n\r\n    /** The global radius of the circle. */\r\n    get globalRadius() { return Vec2.dot(Vec2.half, this.globalScale) * this._radius; }\r\n\r\n    regenerate() {\r\n        this._bounds = new Bounds(\r\n            Vec2.subtract(this.globalPosition, new Vec2(this.globalRadius + Collider.BOUNDS_PADDING, this.globalRadius + Collider.BOUNDS_PADDING)),\r\n            Vec2.add(this.globalPosition, new Vec2(this.globalRadius + Collider.BOUNDS_PADDING, this.globalRadius + Collider.BOUNDS_PADDING)));\r\n    }\r\n\r\n    onDebugDraw(context: CanvasRenderingContext2D): void {\r\n        // Draw vertices\r\n        context.strokeStyle = \"#ff00ff\";\r\n        context.beginPath();\r\n        context.arc(this.globalPosition.x, this.globalPosition.y, this.globalRadius, 0, 360);\r\n        context.stroke();\r\n\r\n        super.onDebugDraw(context);\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Collider from './Collider';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * Base class for convex polygon colliders.\r\n */\r\nexport default abstract class ConvexCollider extends Collider {\r\n    protected _vertices: Vec2[] = [];\r\n    protected _axes: Vec2[] = [];\r\n\r\n    /** The globally positioned vertices of the collider. */\r\n    get vertices() { return this._vertices.slice(); }\r\n\r\n    /** The axes of this collider for SAT. */\r\n    get axes() { return this._axes.slice(); }\r\n\r\n    onDebugDraw(context: CanvasRenderingContext2D): void {\r\n        // Draw vertices\r\n        context.strokeStyle = \"#ff00ff\";\r\n        context.beginPath();\r\n        for (let i = 0; i <= this._vertices.length; ++i) {\r\n            const v = this._vertices[i % this._vertices.length];\r\n            if (i == 0) {\r\n                context.moveTo(v.x, v.y);\r\n            }\r\n            else {\r\n                context.lineTo(v.x, v.y);\r\n            }\r\n        }\r\n        context.stroke();\r\n\r\n        // Draw bb\r\n        context.strokeStyle = \"#00ffff\";\r\n        context.strokeRect(\r\n            this._bounds.min.x,\r\n            this._bounds.min.y,\r\n            this._bounds.size.x,\r\n            this._bounds.size.y);\r\n\r\n        super.onDebugDraw(context);\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Collider from './Collider';\r\nimport Bounds from '../structures/Bounds';\r\nimport Mat3 from '../structures/Mat3';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * A node that has a single line segment collider shape.\r\n */\r\nexport default class LineCollider extends Collider {\r\n    private _direction: Vec2 = Vec2.multiply(Vec2.right, 100);\r\n\r\n    /** The offset of the end from the middle of the line segment. */\r\n    get direction() { return this._direction.copy(); }\r\n    set direction(value: Vec2) {\r\n        this._direction = value.copy();\r\n    }\r\n\r\n    /** The start of the line segment. */\r\n    get start() { return Vec2.subtract(this.position, this._direction); }\r\n    set start(value: Vec2) {\r\n        const end = this.end;\r\n        this.position = Vec2.divide(Vec2.add(value, end), 2);\r\n        this._direction = Vec2.subtract(end, this.position);\r\n    }\r\n\r\n    /** The end of the line segment. */\r\n    get end() { return Vec2.add(this.position, this._direction); }\r\n    set end(value: Vec2) {\r\n        const start = this.start;\r\n        this.position = Vec2.divide(Vec2.add(start, value), 2);\r\n        this._direction = Vec2.subtract(this.position, start);\r\n    }\r\n\r\n    /** The global start of the line segment. */\r\n    get globalStart() { return Vec2.transform(this.globalTransform, Vec2.multiply(this._direction, -1)); }\r\n    set globalStart(value: Vec2) {\r\n        const end = this.globalEnd;\r\n        this.globalPosition = Vec2.divide(Vec2.add(value, end), 2);\r\n        this._direction = Vec2.multiply(Vec2.transform(Mat3.inverse(this.globalTransform), value), -1);\r\n    }\r\n\r\n    /** The global end of the line segment. */\r\n    get globalEnd() { return Vec2.transform(this.globalTransform, this._direction); }\r\n    set globalEnd(value: Vec2) {\r\n        const start = this.globalStart;\r\n        this.globalPosition = Vec2.divide(Vec2.add(start, value), 2);\r\n        this._direction = Vec2.transform(Mat3.inverse(this.globalTransform), value);\r\n    }\r\n\r\n    /** The offset of the global end from the global middle of the line segment. */\r\n    get globalDirection() { return Vec2.divide(Vec2.subtract(this.globalEnd, this.globalStart), 2); }\r\n\r\n    regenerate() {\r\n        this._bounds = Bounds.fromVertices([\r\n            Vec2.subtract(this.globalStart, new Vec2(Collider.BOUNDS_PADDING, Collider.BOUNDS_PADDING)),\r\n            Vec2.subtract(this.globalEnd, new Vec2(Collider.BOUNDS_PADDING, Collider.BOUNDS_PADDING)),\r\n            Vec2.add(this.globalStart, new Vec2(Collider.BOUNDS_PADDING, Collider.BOUNDS_PADDING)),\r\n            Vec2.add(this.globalEnd, new Vec2(Collider.BOUNDS_PADDING, Collider.BOUNDS_PADDING))\r\n        ]);\r\n    }\r\n\r\n    onDebugDraw(context: CanvasRenderingContext2D): void {\r\n        // Draw vertices\r\n        const sGlobal = this.globalStart;\r\n        const eGlobal = this.globalEnd;\r\n        context.strokeStyle = \"#ff00ff\";\r\n        context.beginPath();\r\n        context.moveTo(sGlobal.x, sGlobal.y);\r\n        context.lineTo(eGlobal.x, eGlobal.y);\r\n        context.stroke();\r\n\r\n        super.onDebugDraw(context);\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Body from './Body';\r\nimport Vec2 from '../structures/Vec2';\r\nimport Game from '../Game';\r\n\r\nexport enum EForceType {\r\n    Impulse,\r\n    Force,\r\n}\r\n\r\n/**\r\n * A node that responds to physics and collisions.\r\n*/\r\nexport default class RigidBody extends Body {\r\n    private _mass: number = 1;\r\n\r\n    /** The linear drag. */\r\n    drag: number = 0;\r\n\r\n    /** The force of gravity. */\r\n    gravity: Vec2 = Vec2.zero;\r\n\r\n    /** The mass. */\r\n    get mass() { return this._mass; }\r\n    set mass(value: number) { this._mass = Math.max(value, Number.EPSILON); }\r\n\r\n    addForce(force: Vec2, type: EForceType = EForceType.Impulse) {\r\n        let a: Vec2;\r\n        switch (type) {\r\n            case EForceType.Impulse:\r\n                a = Vec2.multiply(force, 1 / this.mass);\r\n                break;\r\n            case EForceType.Force:\r\n                a = Vec2.multiply(force, Game.deltaTime / this.mass);\r\n                break;\r\n        }\r\n        this.velocity = Vec2.add(this.velocity, a);\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Color from '../structures/Color';\r\nimport IDrawable from './IDrawable';\r\nimport Node from './Node'\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * A node that draws an image on the canvas.\r\n*/\r\nexport default class Sprite extends Node implements IDrawable {\r\n    private static bitmapStore: Map<string, ImageBitmap> = new Map<string, ImageBitmap>();\r\n    private static workingCanvas = new OffscreenCanvas(256, 256);\r\n\r\n    private _image: string | null = null;\r\n    private _color: Color = Color.white;\r\n    private bitmap: ImageBitmap | null = null;\r\n\r\n    /** The normalized pivot. */\r\n    pivot: Vec2 = Vec2.multiply(Vec2.one, 0.5);\r\n\r\n    onDraw(context: CanvasRenderingContext2D): void {\r\n        if (this.bitmap) {\r\n            context.save();\r\n            context.translate(-this.pivot.x * this.bitmap.width, -this.pivot.y * this.bitmap.height);\r\n            context.drawImage(this.bitmap, 0, 0);\r\n            context.restore();\r\n        }\r\n    }\r\n\r\n    /** The image path. */\r\n    get image() { return this._image; }\r\n    set image(value: string | null) {\r\n        const changed = this._image !== value;\r\n        this._image = value;\r\n        if (changed) {\r\n            this.updateBitmap();\r\n        }\r\n    }\r\n\r\n    /** The color. */\r\n    get color() { return this._color; }\r\n    set color(value: Color) {\r\n        const changed = this._color !== value;\r\n        this._color = value;\r\n        if (changed) {\r\n            this.updateBitmap();\r\n        }\r\n    }\r\n\r\n    private async updateBitmap() {\r\n        if (this._image === null) {\r\n            this.bitmap = null;\r\n            return;\r\n        }\r\n        const bmp = await Sprite.load(this._image);\r\n        if (this.color.r == 1 && this.color.g == 1 && this.color.b == 1 && this.color.a == 1) {\r\n            this.bitmap = bmp;\r\n        }\r\n        else {\r\n            let data = Sprite.bitmapToData(bmp);\r\n            Sprite.colorise(data, this.color);\r\n            this.bitmap = Sprite.dataToBitmap(data);\r\n        }\r\n    }\r\n\r\n    private static load(path: string) {\r\n        if (Sprite.bitmapStore.has(path)) {\r\n            return new Promise<ImageBitmap>((resolve) => { resolve(Sprite.bitmapStore.get(path)!) });\r\n        }\r\n        return new Promise<ImageBitmap>((resolve) => {\r\n            let image = new Image();\r\n            image.onload = async () => {\r\n                let bmp = await createImageBitmap(image, 0, 0, image.width, image.height);\r\n                Sprite.bitmapStore.set(path, bmp);\r\n                image.remove();\r\n                resolve(bmp);\r\n            };\r\n            image.src = path;\r\n        });\r\n    }\r\n\r\n    private static unload(path: string) {\r\n        Sprite.bitmapStore.get(path)?.close();\r\n        Sprite.bitmapStore.delete(path);\r\n    }\r\n\r\n    private static bitmapToData(bmp: ImageBitmap) {\r\n        if (Sprite.workingCanvas.width < bmp.width) {\r\n            Sprite.workingCanvas.width = bmp.width;\r\n        }\r\n        if (Sprite.workingCanvas.height < bmp.height) {\r\n            Sprite.workingCanvas.height = bmp.height;\r\n        }\r\n        let ctx = Sprite.workingCanvas.getContext('2d', { willReadFrequently: true })!;\r\n        ctx.clearRect(0, 0, bmp.width, bmp.height);\r\n        ctx.drawImage(bmp, 0, 0);\r\n        return ctx.getImageData(0, 0, bmp.width, bmp.height);\r\n    }\r\n\r\n    private static dataToBitmap(dat: ImageData) {\r\n        if (Sprite.workingCanvas.width != dat.width) {\r\n            Sprite.workingCanvas.width = dat.width;\r\n        }\r\n        if (Sprite.workingCanvas.height != dat.height) {\r\n            Sprite.workingCanvas.height = dat.height;\r\n        }\r\n        let ctx = Sprite.workingCanvas.getContext('2d', { willReadFrequently: true })!;\r\n        ctx.clearRect(0, 0, dat.width, dat.height);\r\n        ctx.putImageData(dat, 0, 0);\r\n        return Sprite.workingCanvas.transferToImageBitmap();\r\n    }\r\n\r\n    private static colorise(img: ImageData, color: Color) {\r\n        for (let p = 0; p < img.data.length; p += 4) {\r\n            const [r, g, b] = [p, p + 1, p + 2];\r\n            img.data[r] *= color.r;\r\n            img.data[g] *= color.g;\r\n            img.data[b] *= color.b;\r\n        }\r\n    }\r\n}","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\n\r\n/**\r\n * Representation of a RGBA color.\r\n */\r\nexport default class Color implements ICopyable, IEquatable {\r\n    /** The red component. */\r\n    r: number = 0;\r\n    /** The green component. */\r\n    g: number = 0;\r\n    /** The blue component. */\r\n    b: number = 0;\r\n    /** The alpha component. */\r\n    a: number = 1;\r\n\r\n    constructor(r: number, g: number, b: number, a?: number) {\r\n        this.r = Math.clamp(r, 0, 1);\r\n        this.g = Math.clamp(g, 0, 1);\r\n        this.b = Math.clamp(b, 0, 1);\r\n        this.a = Math.clamp(a ?? 1, 0, 1);\r\n    }\r\n\r\n    copy = () => new Color(this.r, this.g, this.b, this.a);\r\n    equals = (other: Color) => this.r == other.r && this.g == other.g && this.b == other.b && this.a == other.a;\r\n\r\n    /**\r\n     * Converts the color to its #RRGGBBAA hexadecimal string representation.\r\n     * @param hasAlpha Whether to include the alpha channel.\r\n     * @returns The hexadecimal string representation.\r\n     */\r\n    toHexString = (hasAlpha: boolean = false) => {\r\n        let str: string = \"#\";\r\n        str += ((this.r * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        str += ((this.g * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        str += ((this.b * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        if (hasAlpha) str += ((this.a * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * Converts the color to its HSV representation.\r\n     * @returns The HSV representation.\r\n     */\r\n    toHSV = () => {\r\n        const cmax = Math.max(this.r, this.g, this.b);\r\n        const cmin = Math.min(this.r, this.g, this.b);\r\n        const delta = cmax - cmin;\r\n        let [h, s, v] = [0, cmax === 0 ? 0 : delta / cmax, cmax];\r\n        if (cmax === this.r) {\r\n            h = Math.mod((this.g - this.b) / delta, 6);\r\n        }\r\n        else if (cmax === this.g) {\r\n            h = (this.g - this.b) / delta + 2;\r\n        }\r\n        else {\r\n            h = (this.g - this.b) / delta + 4;\r\n        }\r\n        return { h, s, v };\r\n    }\r\n\r\n    /** Black. */\r\n    static get black() { return new Color(0, 0, 0); }\r\n    /** Blue. */\r\n    static get blue() { return new Color(0, 0, 1); }\r\n    /** Green. */\r\n    static get green() { return new Color(0, 1, 0); }\r\n    /** Cyan. */\r\n    static get cyan() { return new Color(0, 1, 1); }\r\n    /** Red. */\r\n    static get red() { return new Color(1, 0, 0); }\r\n    /** Magenta. */\r\n    static get magenta() { return new Color(1, 0, 1); }\r\n    /** Yellow. */\r\n    static get yellow() { return new Color(1, 1, 0); }\r\n    /** White. */\r\n    static get white() { return new Color(1, 1, 1); }\r\n    /** Grey. */\r\n    static get grey() { return new Color(0.5, 0.5, 0.5); }\r\n    /** Transparent. */\r\n    static get transparent() { return new Color(0, 0, 0, 0); }\r\n\r\n    /**\r\n     * Linearly interpolates from one color to another.\r\n     * @param c1 The first color.\r\n     * @param c2 The second color.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated color.\r\n     */\r\n    static lerp(c1: Color, c2: Color, t: number) {\r\n        return new Color(\r\n            c1.r * (1 - t) + c2.r * t,\r\n            c1.g * (1 - t) + c2.g * t,\r\n            c1.b * (1 - t) + c2.b * t,\r\n            c1.a * (1 - t) + c2.a * t);\r\n    }\r\n\r\n    /**\r\n     * Spherically linearly interpolates from one color to another.\r\n     * @param c1 The first color.\r\n     * @param c2 The second color.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated color.\r\n     */\r\n    static slerp(c1: Color, c2: Color, t: number) {\r\n        const func = (t: number) => Math.sin(t * Math.PI / 2)\r\n        const [u, v] = [func(1 - t), func(t)];\r\n        return new Color(\r\n            c1.r * u + c2.r * v,\r\n            c1.g * u + c2.g * v,\r\n            c1.b * u + c2.b * v,\r\n            c1.a * u + c2.a * v);\r\n    }\r\n\r\n    /**\r\n     * Creates a color from its hexadecimal string representation.\r\n     * @param str The hexadecimal string representation.\r\n     * @returns The color.\r\n     */\r\n    static fromHexString = (str: string) => {\r\n        str = str.trim();\r\n        const r = parseInt(str.substring(1, 3), 16);\r\n        const g = parseInt(str.substring(3, 5), 16);\r\n        const b = parseInt(str.substring(5, 7), 16);\r\n        const a = str.length >= 7 ? parseInt(str.substring(7, 9), 16) : 255;\r\n        return new Color(r / 255, g / 255, b / 255, a / 255);\r\n    }\r\n\r\n    /**\r\n     * Creates a color from its HSV representation.\r\n     * @param h The hue.\r\n     * @param s The saturation.\r\n     * @param v The value.\r\n     * @returns The color.\r\n     */\r\n    static fromHSV = (h: number, s: number, v: number) => {\r\n        h = h * 360;\r\n        const c = s * v;\r\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1));\r\n        const m = v - c;\r\n        let [r, g, b] = [0, 0, 0];\r\n        if (h < 60) {\r\n            [r, g, b] = [c, x, 0];\r\n        }\r\n        else if (h < 120) {\r\n            [r, g, b] = [x, c, 0];\r\n        }\r\n        else if (h < 180) {\r\n            [r, g, b] = [0, c, x];\r\n        }\r\n        else if (h < 240) {\r\n            [r, g, b] = [0, x, c];\r\n        }\r\n        else if (h < 300) {\r\n            [r, g, b] = [x, 0, c];\r\n        }\r\n        else {\r\n            [r, g, b] = [c, 0, x];\r\n        }\r\n        return new Color(r + m, g + m, b + m);\r\n    }\r\n}"],"names":[],"version":3,"file":"Petrallengine.mjs.map"}