{"mappings":"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","sources":["src/Petrallengine.ts","src/Snowflake.ts","src/Game.ts","src/systems/Camera.ts","src/structures/Vec2.ts","src/Math.ts","src/systems/Input.ts","src/nodes/Node.ts","src/structures/Mat3.ts","src/nodes/Collider.ts","src/structures/Bounds.ts","src/nodes/NgonCollider.ts","src/nodes/Sprite.ts","src/structures/Color.ts"],"sourcesContent":["/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nexport * from \"./Snowflake\";\r\nexport { default as Game } from \"./Game\";\r\nexport { default as Collider } from \"./nodes/Collider\";\r\nexport { type default as IDrawable } from \"./nodes/IDrawable\";\r\nexport { default as NgonCollider } from \"./nodes/NgonCollider\";\r\nexport { default as Node } from \"./nodes/Node\";\r\nexport { default as Sprite } from \"./nodes/Sprite\";\r\nexport { default as Color } from \"./structures/Color\";\r\nexport { type default as ICopyable } from \"./structures/ICopyable\";\r\nexport { default as Mat3 } from \"./structures/Mat3\";\r\nexport { default as Vec2 } from \"./structures/Vec2\";\r\nexport { default as Camera } from \"./systems/Camera\";\r\nexport { default as Input } from \"./systems/Input\";\r\n//export * from \"./systems/Physics\";","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\n// Adds two arrays for the given base (10 or 16), returning the result.\r\n// This turns out to be the only \"primitive\" operation we need.\r\nfunction add(x: number[], y: number[], base: number) {\r\n    let z: number[] = [];\r\n    let n = Math.max(x.length, y.length);\r\n    let carry = 0;\r\n    let i = 0;\r\n    while (i < n || carry) {\r\n        let xi = i < x.length ? x[i] : 0;\r\n        let yi = i < y.length ? y[i] : 0;\r\n        let zi = carry + xi + yi;\r\n        z.push(zi % base);\r\n        carry = Math.floor(zi / base);\r\n        i++;\r\n    }\r\n    return z;\r\n}\r\n\r\n// Returns a*x, where x is an array of decimal digits and a is an ordinary\r\n// JavaScript number. base is the number base of the array x.\r\nfunction multiplyByNumber(num: number, x: number[], base: number) {\r\n    if (num < 0 || num == 0) return [];\r\n\r\n    let result: number[] = [];\r\n    let power = x;\r\n    while (true) {\r\n        if (num & 1) {\r\n            result = add(result, power, base);\r\n        }\r\n        num = num >> 1;\r\n        if (num === 0) break;\r\n        power = add(power, power, base);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction parseToDigitsArray(str: string, base: number) {\r\n    let digits = str.split('');\r\n    let ary: number[] = [];\r\n    for (let i = digits.length - 1; i >= 0; i--) {\r\n        let n = parseInt(digits[i], base);\r\n        if (isNaN(n)) return null;\r\n        ary.push(n);\r\n    }\r\n    return ary;\r\n}\r\n\r\nfunction convertBase(str: string, fromBase: number, toBase: number) {\r\n    let digits = parseToDigitsArray(str, fromBase);\r\n    if (digits === null) return null;\r\n\r\n    let outArray: number[] = [];\r\n    let power = [1];\r\n    for (let i = 0; i < digits.length; i++) {\r\n        // invariant: at this point, fromBase^i = power\r\n        if (digits[i]) {\r\n            outArray = add(outArray, multiplyByNumber(digits[i], power, toBase), toBase);\r\n        }\r\n        power = multiplyByNumber(fromBase, power, toBase);\r\n    }\r\n\r\n    let out = '';\r\n    for (let i = outArray.length - 1; i >= 0; i--) {\r\n        out += outArray[i].toString(toBase);\r\n    }\r\n    return out;\r\n}\r\n\r\nfunction decToHex(decStr: string) {\r\n    let hex = convertBase(decStr, 10, 16);\r\n    return hex ? '0x' + hex : null;\r\n}\r\n\r\nfunction hexToDec(hexStr: string) {\r\n    if (hexStr.substring(0, 2) === '0x') hexStr = hexStr.substring(2);\r\n    hexStr = hexStr.toLowerCase();\r\n    return convertBase(hexStr, 16, 10);\r\n}\r\n\r\n/**\r\n * A Snowflake ID.\r\n */\r\nexport type Snowflake = string;\r\n\r\nclass SnowflakeFactory {\r\n    private static readonly TIME_BYTES = 4;\r\n    private static readonly RANDOM_BYTES = 2;\r\n    private static readonly INCREMENT_BYTES = 2;\r\n\r\n    private static increment = 0;\r\n\r\n    static make = () => {\r\n        let id = \"\";\r\n        id += Date.now().toString(16).slice(-SnowflakeFactory.TIME_BYTES * 2).padStart(SnowflakeFactory.TIME_BYTES * 2, '0');\r\n        id += Math.round(Math.random() * Math.pow(256, SnowflakeFactory.RANDOM_BYTES)).toString(16).padStart(SnowflakeFactory.RANDOM_BYTES * 2, '0');\r\n        id += SnowflakeFactory.inc.toString(16).padStart(SnowflakeFactory.INCREMENT_BYTES * 2, '0');\r\n        return id;\r\n    }\r\n\r\n    private static get inc() {\r\n        const lim = Math.pow(256, SnowflakeFactory.INCREMENT_BYTES);\r\n        if (++SnowflakeFactory.increment >= lim) { SnowflakeFactory.increment -= lim; }\r\n        return SnowflakeFactory.increment;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a unique Snowflake ID.\r\n * @returns A unique Snowflake ID.\r\n */\r\nexport const makeSnowflake: () => Snowflake = SnowflakeFactory.make;\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Camera from './systems/Camera';\r\nimport IDrawable from './nodes/IDrawable';\r\nimport Input from './systems/Input';\r\nimport Node from './nodes/Node';\r\n\r\n/**\r\n * Static class for Petrallengine.\r\n * \r\n * Call `Petrallengine.create(MY_CANVAS_ELEMENT)` to start building your 2D browser application.\r\n */\r\nexport default class Game {\r\n    /** The build number. */\r\n    static readonly BUILD = 1;\r\n    /** The version. */\r\n    static readonly VERSION = \"0.0.1\";\r\n    /** The number of scheduled frame updates per second. */\r\n    static readonly FRAME_RATE = 60;\r\n    /** The scheduled interval between frame updates in seconds. */\r\n    static readonly FRAME_TIME = 1 / Game.FRAME_RATE;\r\n\r\n    private static _deltaTime = Game.FRAME_TIME;\r\n    private static _time = 0;\r\n    private static rootNode: Node = new Node(Game);\r\n\r\n    /** The root node of the whole game. */\r\n    static get root() {\r\n        return Game.rootNode;\r\n    }\r\n\r\n    /**\r\n     * Initialises the engine.\r\n     * @param target The target canvas element to render onto.\r\n     */\r\n    static create(target?: HTMLCanvasElement) {\r\n        console.debug(`%cPetrallengine v${Game.VERSION}\\nby Petraller`, 'color: #0799ce');\r\n        console.debug(`https://petraller.com/`);\r\n\r\n        // Fallback target\r\n        if (!target) {\r\n            const targetDefaultID = 'app';\r\n            console.debug(`No canvas provided, using default target canvas #${targetDefaultID}`);\r\n\r\n            const ele = document.getElementById(targetDefaultID);\r\n            if (!ele || !(ele instanceof HTMLCanvasElement)) {\r\n                console.error(`Unable to find a canvas with ID #${targetDefaultID}`);\r\n                console.error(`Please create a canvas element with ID #${targetDefaultID}, or provide your own canvas to Petrallengine.create`);\r\n                return;\r\n            }\r\n\r\n            target = ele as HTMLCanvasElement;\r\n        }\r\n\r\n        console.debug(`Using ${target.outerHTML} as render canvas`);\r\n\r\n        // Initialise systems\r\n        const input = new Input(target);\r\n\r\n        // Create game loop\r\n        const canvas = target;\r\n        const context = canvas.getContext('2d')!;\r\n        const ft = 1000 / Game.FRAME_RATE;\r\n        const gameLoop = () => {\r\n            const tStart = Date.now();\r\n\r\n            // Update all\r\n            function update(node: Node) {\r\n                if (!node.isEnabled)\r\n                    return;\r\n\r\n                if (!node.isStarted) {\r\n                    node.onStart?.call(node);\r\n                    node.isStarted = true;\r\n                }\r\n                node.onUpdate?.call(node);\r\n\r\n                // Iterate children\r\n                for (let child of node.children) {\r\n                    update(child);\r\n                }\r\n            }\r\n            update(Game.rootNode);\r\n\r\n            // Reset\r\n            context.reset();\r\n\r\n            // Clear\r\n            context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n            // Apply camera transforms\r\n            context.translate(canvas.width / 2, canvas.height / 2);\r\n            context.translate(-Camera.position.x, -Camera.position.y);\r\n            context.rotate(-Camera.rotation * Math.PI / 180);\r\n            context.scale(Camera.scale.x, Camera.scale.y);\r\n\r\n            // Draw all\r\n            function draw(node: Node) {\r\n                if (!node.isEnabled)\r\n                    return;\r\n\r\n                context.save();\r\n\r\n                // Apply node transforms\r\n                context.translate(node.position.x, node.position.y);\r\n                context.rotate(node.rotation * Math.PI / 180);\r\n                context.scale(node.scale.x, node.scale.y);\r\n\r\n                // Draw drawables\r\n                if ('onDraw' in node && node.onDraw instanceof Function) {\r\n                    node.onDraw.call(node, context);\r\n                }\r\n\r\n                // Iterate children\r\n                for (let child of node.children) {\r\n                    draw(child);\r\n                }\r\n\r\n                context.restore();\r\n            }\r\n            draw(Game.rootNode);\r\n\r\n            // Clear transition flags\r\n            input._endFrame();\r\n\r\n            const tEnd = Date.now();\r\n            const dt = tEnd - tStart;\r\n            const wait = Math.max(ft - dt, 0);\r\n            Game._time += (Game._deltaTime = dt + wait);\r\n            setTimeout(gameLoop, wait);\r\n        };\r\n        gameLoop();\r\n    }\r\n\r\n    /**\r\n     * Returns the total elapsed game time in seconds.\r\n     */\r\n    static get time() {\r\n        return Game._time / 1000;\r\n    }\r\n\r\n    /**\r\n     * Returns the actual elapsed time for the frame in seconds.\r\n     */\r\n    static get deltaTime() {\r\n        return Game._deltaTime / 1000;\r\n    }\r\n};\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * Static class for moving the viewport in the world space.\r\n */\r\nexport default class Camera {\r\n    /**\r\n     * The position of the camera.\r\n     */\r\n    static position: Vec2 = Vec2.zero;\r\n\r\n    /**\r\n     * The rotation of the camera.\r\n     */\r\n    static rotation: number = 0;\r\n\r\n    /**\r\n     * The scale of the camera.\r\n     */\r\n    static scale: Vec2 = Vec2.one;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\nimport Mat3 from './Mat3';\r\n\r\n/**\r\n * Representation of a 2D vector.\r\n */\r\nexport default class Vec2 implements ICopyable, IEquatable {\r\n    /** The x-component. */\r\n    x: number = 0;\r\n    /** The y-component. */\r\n    y: number = 0;\r\n\r\n    constructor(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    copy = () => new Vec2(this.x, this.y);\r\n    copyFrom = (other: Vec2) => { this.x = other.x; this.y = other.y; return this; };\r\n    equals = (other: Vec2) => this.x === other.x && this.y === other.y;\r\n\r\n    /**\r\n     * Returns the squared length of this vector.\r\n     * @returns The squared length of this vector.\r\n     */\r\n    get sqrLength() { return this.x * this.x + this.y * this.y; }\r\n\r\n    /**\r\n     * Returns the length of this vector.\r\n     * @returns The length of this vector.\r\n     */\r\n    get length() { return Math.sqrt(this.sqrLength); }\r\n\r\n    /**\r\n     * Returns the normalized form of this vector.\r\n     * @returns The normalized form of this vector.\r\n     */\r\n    get normalized() { const l = this.length; return l == 0 ? Vec2.zero : Vec2.divide(this, l); };\r\n\r\n    /**\r\n     * Returns the value of the minimum component of this vector.\r\n     * @returns The value of the minimum component of this vector.\r\n     */\r\n    get minComponent() { return this.x < this.y ? this.x : this.y; }\r\n\r\n    /**\r\n     * Returns the value of the maximum component of this vector.\r\n     * @returns The value of the maximum component of this vector.\r\n     */\r\n    get maxComponent() { return this.x > this.y ? this.x : this.y; }\r\n\r\n    /**\r\n     * Normalizes this vector.\r\n     * @returns This vector after normalizing.\r\n     */\r\n    normalize = () => { const l = this.length; return this.scale(l == 0 ? 0 : 1 / l); };\r\n\r\n    /**\r\n     * Translates this vector by another vector.\r\n     * @param v The other vector.\r\n     * @returns This vector after translating.\r\n     */\r\n    translate = (v: Vec2) => { this.x += v.x; this.y += v.y; return this; };\r\n\r\n    /**\r\n     * Rotates this vector by an angle.\r\n     * @param deg The angle in degrees.\r\n     * @returns This vector after rotating.\r\n     */\r\n    rotate = (deg: number) => {\r\n        const r = deg * Math.PI / 180;\r\n        const x = Math.cos(r) * this.x - Math.sin(r) * this.y;\r\n        const y = Math.sin(r) * this.x + Math.cos(r) * this.y;\r\n        this.x = x; this.y = y;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Scales this vector by a factor.\r\n     * @param n The scaling factor.\r\n     * @returns This vector after scaling.\r\n     */\r\n    scale = (n: number) => { this.x *= n; this.y *= n; return this; };\r\n\r\n    /**\r\n     * Scales this vector by another vector component-wise.\r\n     * @param v The other vector.\r\n     * @returns This vector after scaling.\r\n     */\r\n    scaleComponents = (v: Vec2) => { this.x *= v.x; this.y *= v.y; return this; };\r\n\r\n    /**\r\n     * Inverts this vector component-wise.\r\n     * @returns This vector after inverting.\r\n     */\r\n    invert = () => { this.x = 1 / this.x; this.y = 1 / this.y; return this; }\r\n\r\n    /**\r\n     * Transforms this vector by a matrix.\r\n     * @param m The matrix.\r\n     * @returns This vector after transforming.\r\n     */\r\n    transform = (m: Mat3) => {\r\n        const x = this.x * m.m[0][0] + this.y * m.m[0][1] + m.m[0][2];\r\n        const y = this.x * m.m[1][0] + this.y * m.m[1][1] + m.m[1][2];\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    };\r\n\r\n    /** The zero vector. */\r\n    static get zero() { return new Vec2(0, 0); }\r\n    /** The unit vector. */\r\n    static get one() { return new Vec2(1, 1); }\r\n    /** The right vector. */\r\n    static get right() { return new Vec2(1, 0); }\r\n    /** The left vector. */\r\n    static get left() { return new Vec2(-1, 0); }\r\n    /** The down vector. */\r\n    static get down() { return new Vec2(0, 1); }\r\n    /** The up vector. */\r\n    static get up() { return new Vec2(0, -1); }\r\n    /** The negative infinity vector. */\r\n    static get negativeInfinity() { return new Vec2(-Infinity, -Infinity); }\r\n    /** The infinity vector. */\r\n    static get infinity() { return new Vec2(Infinity, Infinity); }\r\n\r\n    /**\r\n     * Adds two vectors component-wise.\r\n     * \r\n     * Does not modify the original vectors.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The sum vector.\r\n     */\r\n    static add = (v1: Vec2, v2: Vec2) => new Vec2(v1.x + v2.x, v1.y + v2.y);\r\n\r\n    /**\r\n     * Multiplies a vector by a constant.\r\n     * \r\n     * Does not modify the original vector.\r\n     * @param v The vector.\r\n     * @param n The constant\r\n     * @returns The scaled vector.\r\n     */\r\n    static multiply = (v: Vec2, n: number) => new Vec2(v.x * n, v.y * n);\r\n\r\n    /**\r\n     * Multiplies two vectors component-wise.\r\n     * \r\n     * Does not modify the original vectors.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The scaled vector.\r\n     */\r\n    static multiplyComponents = (v1: Vec2, v2: Vec2) => new Vec2(v1.x * v2.x, v1.y * v2.y);\r\n\r\n    /**\r\n     * Subtracts one vector from another.\r\n     * \r\n     * Does not modify the original vectors.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The difference vector.\r\n     */\r\n    static subtract = (v1: Vec2, v2: Vec2) => Vec2.add(v1, Vec2.multiply(v2, -1));\r\n\r\n    /**\r\n     * Divides a vector by a constant.\r\n     * \r\n     * Does not modify the original vector.\r\n     * @param v The vector.\r\n     * @param n The constant.\r\n     * @returns The scaled vector.\r\n     */\r\n    static divide = (v: Vec2, n: number) => Vec2.multiply(v, 1 / n);\r\n\r\n    /**\r\n     * Inverts a vector component-wise.\r\n     * \r\n     * Does not modify the original vector.\r\n     * @param v The vector.\r\n     * @returns The inverted vector.\r\n     */\r\n    static inverse = (v: Vec2) => new Vec2(1 / v.x, 1 / v.y);\r\n\r\n    /**\r\n     * Dot multiplies two vectors.\r\n     * \r\n     * Does not modify the original vectors.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The dot product.\r\n     */\r\n    static dot = (v1: Vec2, v2: Vec2) => v1.x * v2.x + v1.y * v2.y;\r\n\r\n    /**\r\n     * Cross multiplies two vectors.\r\n     * \r\n     * Does not modify the original vectors.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The magnitude of the cross product.\r\n     */\r\n    static cross = (v1: Vec2, v2: Vec2) => v1.x * v2.y - v1.y * v2.x;\r\n\r\n    /**\r\n     * Converts an angle in degrees to a unit vector.\r\n     * @param deg The angle in degrees.\r\n     * @returns The vector.\r\n     */\r\n    static fromAngle = (deg: number) => { const r = deg * Math.PI / 180; return new Vec2(Math.cos(r), Math.sin(r)); };\r\n\r\n    /**\r\n     * Converts a vector to its angle from the x-axis.\r\n     * @param v The vector.\r\n     * @returns The angle in degrees.\r\n     */\r\n    static toAngle = (v: Vec2) => {\r\n        if (v.x == 0)\r\n            return v.y >= 0 ? 90 : -90;\r\n        return (v.x > 0 ? 0 : (v.y > 0 ? 180 : -180)) + Math.atan(v.y / v.x) * 180 / Math.PI;\r\n    }\r\n\r\n    /**\r\n     * Converts an arbitrary object with x and y properties to a vector.\r\n     * @param obj The object.\r\n     * @returns The vector.\r\n     */\r\n    static fromObjXY = (obj: { x: number, y: number }) => new Vec2(obj.x, obj.y);\r\n\r\n    /**\r\n     * Converts an arbitrary object with width and height properties to a vector.\r\n     * @param obj The object.\r\n     * @returns The vector.\r\n     */\r\n    static fromObjWH = (obj: { width: number, height: number }) => new Vec2(obj.width, obj.height);\r\n\r\n    /**\r\n     * Linearly interpolates from one vector to another.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated vector.\r\n     */\r\n    static lerp = (v1: Vec2, v2: Vec2, t: number) => new Vec2(Math.lerp(v1.x, v2.x, t), Math.lerp(v1.y, v2.y, t));\r\n\r\n    /**\r\n     * Linearly interpolates from one vector to another.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated vector.\r\n     */\r\n    static lerpComponents = (v1: Vec2, v2: Vec2, t: Vec2) => new Vec2(Math.lerp(v1.x, v2.x, t.x), Math.lerp(v1.y, v2.y, t.y));\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\n/** */\r\ninterface Math {\r\n    /**\r\n     * Linearly interpolates from one value to another.\r\n     * @param x The first value.\r\n     * @param y The second value.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated value.\r\n     */\r\n    lerp(x: number, y: number, t: number): number;\r\n\r\n    /**\r\n     * Clamps a value between two values.\r\n     * @param x The value to clamp.\r\n     * @param min The minimum value.\r\n     * @param max The maximum value.\r\n     * @returns The clamped value.\r\n     */\r\n    clamp(x: number, min: number, max: number): number;\r\n\r\n    /**\r\n     * Performs a modified modulo operation on two numbers.\r\n     * \r\n     * The operation will yield the positive remainder of the dividend divided by the absolute value of the divisor.\r\n     * @param x The dividend.\r\n     * @param y The divisor.\r\n     * @returns The remainder.\r\n     */\r\n    mod(x: number, y: number): number;\r\n}\r\n\r\nMath.lerp = (x: number, y: number, t: number) => x * (1 - t) + y * t;\r\nMath.clamp = (x: number, min: number, max: number) => Math.min(Math.max(x, min), max);\r\nMath.mod = (x: number, y: number) => (x >= 0) ? (x % Math.abs(y)) : (Math.abs(y) - (-x % Math.abs((y))) % Math.abs(y));\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Camera from './Camera';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * Static class for input handling.\r\n */\r\nexport default class Input {\r\n    private static singleton: Input | null = null;\r\n    private static canvas: HTMLCanvasElement | null = null;\r\n    private static keyStates: Map<string, boolean> = new Map<string, boolean>();\r\n    private static keyTransits: Map<string, boolean> = new Map<string, boolean>();\r\n    private static mouseStates: Map<number, boolean> = new Map<number, boolean>();\r\n    private static mouseTransits: Map<number, boolean> = new Map<number, boolean>();\r\n    private static mousePos: Vec2 = Vec2.zero;\r\n\r\n    constructor(canvas: HTMLCanvasElement) {\r\n        if (Input.singleton) {\r\n            console.warn(\"Input is used as a static class, do not create additional objects of Input\");\r\n            return;\r\n        }\r\n\r\n        // Register canvas events\r\n        Input.canvas = canvas;\r\n        canvas.onmousedown = (ev) => {\r\n            const b = ev.button;\r\n            Input.mouseStates.set(b, true);\r\n            Input.mouseTransits.set(b, true);\r\n        };\r\n        canvas.onmouseup = (ev) => {\r\n            const b = ev.button;\r\n            Input.mouseStates.set(b, false);\r\n            Input.mouseTransits.set(b, true);\r\n        };\r\n        canvas.onmousemove = (ev) => {\r\n            Input.mousePos = new Vec2(ev.offsetX, ev.offsetY);\r\n        };\r\n\r\n        // Register window events\r\n        window.onkeydown = (ev) => {\r\n            const c = ev.code;\r\n            if (!ev.repeat) {\r\n                Input.keyStates.set(c, true);\r\n                Input.keyTransits.set(c, true);\r\n            }\r\n        };\r\n        window.onkeyup = (ev) => {\r\n            const c = ev.code;\r\n            Input.keyStates.set(c, false);\r\n            Input.keyTransits.set(c, true);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Clears all internal flags at the end of the frame.\r\n     * \r\n     * Called by `Petrallengine.create`.\r\n     */\r\n    _endFrame() {\r\n        for (let i of Input.keyTransits.keys()) {\r\n            Input.keyTransits.set(i, false);\r\n        }\r\n        for (let i of Input.mouseTransits.keys()) {\r\n            Input.mouseTransits.set(i, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns whether a keyboard key is down.\r\n     * @param keyCode The code of the key.\r\n     * @returns Whether the key is down.\r\n     */\r\n    static isKey(keyCode: string) {\r\n        return Input.keyStates.get(keyCode) ?? false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether a keyboard key was pressed this frame.\r\n     * @param keyCode The code of the key.\r\n     * @returns Whether the key was pressed this frame.\r\n     */\r\n    static isKeyPressed(keyCode: string) {\r\n        return (Input.keyTransits.get(keyCode) ?? false) && Input.isKey(keyCode);\r\n    }\r\n\r\n    /**\r\n     * Returns whether a keyboard key was released this frame.\r\n     * @param keyCode The code of the key.\r\n     * @returns Whether the key was released this frame.\r\n     */\r\n    static isKeyReleased(keyCode: string) {\r\n        return (Input.keyTransits.get(keyCode) ?? false) && !Input.isKey(keyCode);\r\n    }\r\n\r\n    /**\r\n     * Returns whether a mouse button is down.\r\n     * @param button The mouse button.\r\n     * @returns Whether the mouse button is down.\r\n     */\r\n    static isMouse(button: number = 0) {\r\n        return Input.mouseStates.get(button) ?? false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether a mouse button was pressed this frame.\r\n     * @param button The mouse button.\r\n     * @returns Whether the mouse button was pressed this frame.\r\n     */\r\n    static isMousePressed(button: number = 0) {\r\n        return (Input.mouseTransits.get(button) ?? false) && Input.isMouse(button);\r\n    }\r\n\r\n    /**\r\n     * Returns whether a mouse button was released this frame.\r\n     * @param button The mouse button.\r\n     * @returns Whether the mouse button was released this frame.\r\n     */\r\n    static isMouseReleased(button: number = 0) {\r\n        return (Input.mouseTransits.get(button) ?? false) && !Input.isMouse(button);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the mouse in the canvas.\r\n     * @returns The position of the mouse in the canvas.\r\n     */\r\n    static getMousePosition() {\r\n        return Input.mousePos;\r\n    }\r\n\r\n    /**\r\n     * Returns the normalized position of the mouse in the canvas.\r\n     * @returns The normalized position of the mouse in the canvas.\r\n     */\r\n    static getMousePositionNormalized() {\r\n        return Vec2.multiplyComponents(Input.mousePos, new Vec2(1 / Input.canvas!.width, 1 / Input.canvas!.height));\r\n    }\r\n\r\n    /**\r\n     * Returns the position on the canvas of a world position.\r\n     * @returns The position on the canvas of a world position.\r\n     */\r\n    static worldToCanvas(worldPos: Vec2) {\r\n        return worldPos.copy()\r\n            .scaleComponents(Camera.scale)\r\n            .rotate(-Camera.rotation)\r\n            .translate(Vec2.multiply(Camera.position, -1))\r\n            .translate(Vec2.fromObjWH(Input.canvas!).scale(0.5));\r\n    }\r\n\r\n    /**\r\n     * Returns the position in the world of a canvas position.\r\n     * @returns The position in the world of a canvas position.\r\n     */\r\n    static canvasToWorld(canvasPos: Vec2) {\r\n        return canvasPos.copy()\r\n            .translate(Vec2.fromObjWH(Input.canvas!).scale(-0.5))\r\n            .translate(Camera.position)\r\n            .rotate(Camera.rotation)\r\n            .scaleComponents(Vec2.inverse(Camera.scale));\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Vec2 from '../structures/Vec2';\r\nimport Mat3 from '../structures/Mat3';\r\nimport { Snowflake, makeSnowflake } from '../Snowflake';\r\n\r\ntype Constructor<T> = { new(...args: any[]): T };\r\n\r\n/**\r\n * Base class for all nodes in the scene tree.\r\n * \r\n * Overrideable callbacks:\r\n * - onCreate\r\n * - onStart\r\n * - onDestroy\r\n * - onEnable\r\n * - onDisable\r\n * - onUpdate\r\n */\r\nexport default class Node {\r\n    private _isEnabled: boolean = true;\r\n    private _position: Vec2 = Vec2.zero;\r\n    private _rotation: number = 0;\r\n    private _scale: Vec2 = Vec2.one;\r\n    private _parent: Node | null = null;\r\n    private _transform: Mat3 = Mat3.identity;\r\n    private _isDirty = false;\r\n\r\n    /** The unique Snowflake ID of this node. */\r\n    readonly id: Snowflake = makeSnowflake();\r\n\r\n    /** The name of this node. */\r\n    name: string = \"New Node\";\r\n    /** The children nodes of this node. */\r\n    children: Node[] = [];\r\n    /** Whether this node has started. */\r\n    isStarted: boolean = false;\r\n\r\n    /**\r\n     * Avoid calling `new Node`, call `Petrallengine.root.createChild` instead.\r\n     */\r\n    constructor(flag?: any) {\r\n        if (!flag) {\r\n            console.warn(`Avoid calling \\`new Node\\`, call \\`Petrallengine.root.createChild\\` instead`);\r\n            console.trace(`\\`new Node\\` call occured here:`);\r\n        }\r\n    }\r\n\r\n    toString() { return `${this.name}#${this.id}`; }\r\n\r\n    /** The enabled state of this node. */\r\n    get isEnabled() { return this._isEnabled; }\r\n    set isEnabled(value: boolean) {\r\n        this._isEnabled = value;\r\n        if (value) {\r\n            this.onEnable?.call(this);\r\n        }\r\n        else {\r\n            this.onDisable?.call(this);\r\n        }\r\n    }\r\n\r\n    /** The position of this node. */\r\n    get position() { this._isDirty = true; return this._position; }\r\n    set position(value: Vec2) { this._position = value; this._isDirty = true; }\r\n\r\n    /** The rotation in degrees of this node. */\r\n    get rotation() { this._isDirty = true; return this._rotation; }\r\n    set rotation(value: number) { this._rotation = (value + 180) % 360 - 180; this._isDirty = true; }\r\n\r\n    /** The scale of this node. */\r\n    get scale() { this._isDirty = true; return this._scale; }\r\n    set scale(value: Vec2) { this._scale = value; this._isDirty = true; }\r\n\r\n    /** The transformation matrix of this node. */\r\n    get transform() { return this._transform; }\r\n\r\n    /** The parent node of this node. */\r\n    get parent() { return this._parent; }\r\n    set parent(value: Node | null) {\r\n        if (value && value.isDescendantOf(this)) {\r\n            // Hey stop that. No circular hierarchy pls\r\n            console.error(`Making \\`${value.toString()}\\` a parent of \\`${this.toString()}\\` will create a circular hierarchy`);\r\n            return;\r\n        }\r\n        if (this._parent) {\r\n            const i = this._parent.children.indexOf(this);\r\n            if (i !== -1) {\r\n                this._parent.children.splice(i, 1);\r\n            }\r\n        }\r\n        this._parent = value;\r\n        if (this._parent) {\r\n            this._parent.children.push(this);\r\n        }\r\n    }\r\n\r\n    /** The sibling index of this node. */\r\n    get siblingIndex() {\r\n        if (!this._parent)\r\n            return 0;\r\n        return this._parent.children.indexOf(this);\r\n    }\r\n    set siblingIndex(value: number) {\r\n        if (!this._parent)\r\n            return;\r\n        const i = this.siblingIndex;\r\n        this._parent.children.splice(i, 1);\r\n        this._parent.children.splice(value, 0, this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new child node of this node.\r\n     * @returns The child node.\r\n     */\r\n    createChild<T extends Node>(type: Constructor<T>) {\r\n        const node = new type(this.createChild);\r\n        node.parent = this;\r\n        node.onCreate?.call(node);\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Destroys this node and all children nodes.\r\n     */\r\n    destroy() {\r\n        for (let child of this.children) {\r\n            child.destroy();\r\n        }\r\n        this.onDestroy?.call(this);\r\n        this.parent = null;\r\n    }\r\n\r\n    /**\r\n     * Finds a descendant node by its name.\r\n     * @param name The name of the node.\r\n     * @returns The node, or null if not found.\r\n     */\r\n    findDescendantByName(name: string): Node | null {\r\n        for (let child of this.children) {\r\n            if (child.name == name)\r\n                return child;\r\n        }\r\n        for (let child of this.children) {\r\n            const result = child.findDescendantByName(name);\r\n            if (result)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Finds a descendant node by its type.\r\n     * @param type The type of the node.\r\n     * @returns The node, or null if not found.\r\n     */\r\n    findDescendantByType<T>(type: Constructor<T>): T | null {\r\n        for (let child of this.children) {\r\n            if (child instanceof type)\r\n                return child;\r\n        }\r\n        for (let child of this.children) {\r\n            const result = child.findDescendantByType(type);\r\n            if (result)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Determines if this node is a descendent of another node.\r\n     * @param node The other node.\r\n     * @returns Whether this node is a descendant.\r\n     */\r\n    isDescendantOf(node: Node) {\r\n        let curr = this.parent;\r\n        while (curr !== null) {\r\n            if (curr === node)\r\n                return true;\r\n            curr = curr.parent;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Recalculates the transformation matrix and unsets the dirty flag.\r\n     */\r\n    recalculateTransformMatrix() {\r\n        if (!this._isDirty)\r\n            return;\r\n        this._transform = Mat3.matrixMultiply(\r\n            Mat3.matrixMultiply(\r\n                Mat3.makeTranslation(this._position),\r\n                Mat3.makeRotation(this._rotation)\r\n            ), Mat3.makeScaling(this._scale)\r\n        );\r\n        this._isDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Called when the node is created.\r\n     */\r\n    onCreate?(): void;\r\n\r\n    /**\r\n     * Called when the node is first ticked.\r\n     */\r\n    onStart?(): void;\r\n\r\n    /**\r\n     * Called when the node is destroyed.\r\n     */\r\n    onDestroy?(): void;\r\n\r\n    /**\r\n     * Called when the node is enabled.\r\n     */\r\n    onEnable?(): void;\r\n\r\n    /**\r\n     * Called when the node is disabled.\r\n     */\r\n    onDisable?(): void;\r\n\r\n    /**\r\n     * Called when the node is ticked.\r\n     */\r\n    onUpdate?(): void;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\nimport Vec2 from './Vec2';\r\n\r\ntype Row = [number, number, number];\r\ntype Column = [number, number, number];\r\ntype Matrix = [Row, Row, Row]; /* your boat */\r\n\r\n/**\r\n * Representation of a 3x3 matrix.\r\n */\r\nexport default class Mat3 implements ICopyable, IEquatable {\r\n    /** The matrix. */\r\n    m: Matrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\r\n\r\n    constructor(m?: Matrix) {\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                this.m[r][c] = m ? m[r][c] : 0;\r\n    }\r\n\r\n    copy = () => new Mat3(this.m);\r\n    copyFrom = (other: Mat3) => {\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                this.m[r][c] = other.m[r][c];\r\n        return this;\r\n    }\r\n    equals = (other: Mat3) => {\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                if (this.m[r][c] !== other.m[r][c])\r\n                    return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the determinant of this matrix.\r\n     * @returns The determinant of this matrix.\r\n     */\r\n    get determinant() {\r\n        return this.m[0][0] * (this.m[1][1] * this.m[2][2] - this.m[1][2] * this.m[2][1]) +\r\n            this.m[0][1] * (this.m[1][2] * this.m[2][0] - this.m[1][0] * this.m[2][2]) +\r\n            this.m[0][2] * (this.m[1][0] * this.m[2][1] - this.m[1][1] * this.m[2][0]);\r\n    }\r\n\r\n    /**\r\n     * Retrieves an element of the matrix.\r\n     * \r\n     * Shorthand for `Mat3.m[r][c]`.\r\n     * @param r The row index.\r\n     * @param c The column index.\r\n     * @returns The element.\r\n     */\r\n    get = (r: number, c: number) => this.m[r][c];\r\n\r\n    /**\r\n     * Sets an element of the matrix.\r\n     * \r\n     * Shorthand for `Mat3.m[r][c] = value`.\r\n     * @param r The row index.\r\n     * @param c The column index.\r\n     * @param value The value.\r\n     * @returns This matrix after setting.\r\n     */\r\n    set = (r: number, c: number, value: number) => { this.m[r][c] = value; return this; }\r\n\r\n    /**\r\n     * Retrieves a row of the matrix.\r\n     * @param r The row index.\r\n     * @returns The row.\r\n     */\r\n    getRow = (r: number): Row => [this.m[r][0], this.m[r][1], this.m[r][2]];\r\n\r\n    /**\r\n     * Retrieves a column of the matrix.\r\n     * @param c The column index.\r\n     * @returns The column.\r\n     */\r\n    getColumn = (c: number): Column => [this.m[0][c], this.m[1][c], this.m[2][c]];\r\n\r\n    /**\r\n     * Retrieves a minor of the matrix.\r\n     * @param r The row index to omit.\r\n     * @param c The column index to omit.\r\n     * @returns The minor.\r\n     */\r\n    getMinor = (r: number, c: number): [[number, number], [number, number]] => [\r\n        r == 0\r\n            ? [c == 0 ? this.m[1][1] : this.m[1][0], c == 2 ? this.m[1][1] : this.m[1][2]]\r\n            : [c == 0 ? this.m[0][1] : this.m[0][0], c == 2 ? this.m[0][1] : this.m[0][2]],\r\n        r == 2\r\n            ? [c == 0 ? this.m[1][1] : this.m[1][0], c == 2 ? this.m[1][1] : this.m[1][2]]\r\n            : [c == 0 ? this.m[2][1] : this.m[2][0], c == 2 ? this.m[2][1] : this.m[2][2]]\r\n    ];\r\n\r\n    /**\r\n     * Retrieves the determinant of a cofactor of the matrix.\r\n     * @param r The row index of the element.\r\n     * @param c The column index of the element.\r\n     * @returns The determinant of the cofactor.\r\n     */\r\n    getCofactorDeterminant = (r: number, c: number) => {\r\n        let minor = this.getMinor(r, c);\r\n        let i = (r + c) % 2 === 0 ? 1 : -1;\r\n        return i * (minor[0][0] * minor[1][1] - minor[1][0] * minor[0][1]);\r\n    }\r\n\r\n    /**\r\n     * Transposes the matrix.\r\n     * @returns This matrix after transposition.\r\n     */\r\n    transpose = () => {\r\n        this.m = ([\r\n            [this.m[0][0], this.m[1][0], this.m[2][0]],\r\n            [this.m[0][1], this.m[1][1], this.m[2][1]],\r\n            [this.m[0][2], this.m[1][2], this.m[2][2]]\r\n        ]);\r\n        return this;\r\n    }\r\n\r\n    /** The zero matrix. */\r\n    static get zero() { return new Mat3([[0, 0, 0], [0, 0, 0], [0, 0, 0]]); }\r\n    /** The identity matrix. */\r\n    static get identity() { return new Mat3([[1, 0, 0], [0, 1, 0], [0, 0, 1]]); }\r\n\r\n    /**\r\n     * Adds two matrices component-wise.\r\n     * \r\n     * Does not modify the original matrices.\r\n     * @param m1 The first matrix.\r\n     * @param m2 The second matrix.\r\n     * @returns The sum matrix.\r\n     */\r\n    static add = (m1: Mat3, m2: Mat3) => {\r\n        let result = new Mat3();\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                result.m[r][c] = m1.m[r][c] + m2.m[r][c];\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Multiplies a matrix by a constant.\r\n     * \r\n     * Does not modify the original matrix.\r\n     * @param m The matrix.\r\n     * @param n The constant\r\n     * @returns The scaled matrix.\r\n     */\r\n    static multiply = (m: Mat3, n: number) => {\r\n        let result = new Mat3();\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                result.m[r][c] = m.m[r][c] * n;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Multiplies two matrices.\r\n     * \r\n     * Does not modify the original matrices.\r\n     * @param m1 The first matrix.\r\n     * @param m2 The second matrix.\r\n     * @returns The multiplied matrix.\r\n     */\r\n    static matrixMultiply = (m1: Mat3, m2: Mat3) => {\r\n        let result = new Mat3();\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                for (let i = 0; i < 3; ++i)\r\n                    result.m[r][c] += m1.m[r][i] * m2.m[i][c];\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Subtracts one matrix from another.\r\n     * \r\n     * Does not modify the original matrices.\r\n     * @param m1 The first matrix.\r\n     * @param m2 The second matrix.\r\n     * @returns The difference matrix.\r\n     */\r\n    static subtract = (m1: Mat3, m2: Mat3) => Mat3.add(m1, Mat3.multiply(m2, -1));\r\n\r\n    /**\r\n     * Divides a matrix by a constant.\r\n     * \r\n     * Does not modify the original matrix.\r\n     * @param m The matrix.\r\n     * @param n The constant\r\n     * @returns The scaled matrix.\r\n     */\r\n    static divide = (m: Mat3, n: number) => Mat3.multiply(m, 1 / n);\r\n\r\n    /**\r\n     * Inverts a matrix. If the matrix is not invertible, an error is thrown.\r\n     * \r\n     * Does not modify the original matrix.\r\n     * @param m The matrix.\r\n     * @returns The inverse matrix.\r\n     */\r\n    static inverse = (m: Mat3) => {\r\n        const det = m.determinant;\r\n        if (det === 0) {\r\n            console.error(`Matrix ${m.m} is not invertible`);\r\n            return m;\r\n        }\r\n        return Mat3.multiply(new Mat3([\r\n            [m.getCofactorDeterminant(0, 0), m.getCofactorDeterminant(1, 0), m.getCofactorDeterminant(2, 0)],\r\n            [m.getCofactorDeterminant(0, 1), m.getCofactorDeterminant(1, 1), m.getCofactorDeterminant(2, 1)],\r\n            [m.getCofactorDeterminant(0, 2), m.getCofactorDeterminant(1, 2), m.getCofactorDeterminant(2, 2)]\r\n        ]), 1 / det);\r\n    }\r\n\r\n    /**\r\n     * Constructs a translation matrix.\r\n     * @param v The translation vector.\r\n     * @returns The translation matrix.\r\n     */\r\n    static makeTranslation = (v: Vec2) => {\r\n        return Mat3.identity.set(0, 2, v.x).set(1, 2, v.y);\r\n    }\r\n\r\n    /**\r\n     * Constructs a rotation matrix.\r\n     * @param deg The rotation in degrees.\r\n     * @returns The rotation matrix.\r\n     */\r\n    static makeRotation = (deg: number) => {\r\n        const r = deg * Math.PI / 180;\r\n        return Mat3.identity\r\n            .set(0, 0, Math.cos(r)).set(0, 1, -Math.sin(r))\r\n            .set(1, 0, Math.sin(r)).set(1, 1, Math.cos(r));\r\n    }\r\n\r\n    /**\r\n     * Constructs a scaling matrix.\r\n     * @param v The scaling vector.\r\n     * @returns The scaling matrix.\r\n     */\r\n    static makeScaling = (v: Vec2) => {\r\n        return Mat3.identity.set(0, 0, v.x).set(1, 1, v.y);\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Bounds from '../structures/Bounds';\r\nimport Node from './Node';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * Base class for all collider nodes.\r\n * \r\n * A collider must have a parent PhysicsBody to detect collisions.\r\n */\r\nexport default abstract class Collider extends Node {\r\n    protected _bounds = Bounds.zero;\r\n    protected _axes: Vec2[] = [];\r\n\r\n    /** The transform-agnostic bounds of this collider. */\r\n    get bounds() { return this._bounds; }\r\n\r\n    /** The transform-agnostic axes of this collider for SAT. */\r\n    get axes() { return this._axes; }\r\n\r\n    /**\r\n     * Regenerates the transform-agnostic cached properties of the collider.\r\n     * \r\n     * Implementation defined by the collider subtype.\r\n     */\r\n    abstract regenerate(): void;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\nimport Vec2 from './Vec2';\r\n\r\n/**\r\n * Representation of 2D bounds.\r\n */\r\nexport default class Bounds implements ICopyable, IEquatable {\r\n    /** The minimum components. */\r\n    min: Vec2 = Vec2.zero;\r\n    /** The maximum components. */\r\n    max: Vec2 = Vec2.zero;\r\n\r\n    constructor(min: Vec2, max: Vec2) {\r\n        this.min.copyFrom(min);\r\n        this.max.copyFrom(max);\r\n    }\r\n\r\n    copy = () => new Bounds(this.min, this.max);\r\n    copyFrom = (other: Bounds) => { this.min.copyFrom(other.min); this.max.copyFrom(other.max); return this; };\r\n    equals = (other: Bounds) => this.min.equals(other.min) && this.max.equals(other.max);\r\n\r\n    /** The size of the bounds. */\r\n    get size() { return Vec2.subtract(this.max, this.min); }\r\n\r\n    /**\r\n     * Updates this bounds based on a set of vertices.\r\n     * @param vertices The vertices.\r\n     */\r\n    fromVertices = (vertices: Vec2[]) => {\r\n        this.min = Vec2.infinity;\r\n        this.max = Vec2.negativeInfinity;\r\n\r\n        // Iterate all vertices\r\n        for (const vertex of vertices) {\r\n            if (vertex.x > this.max.x)\r\n                this.max.x = vertex.x;\r\n            if (vertex.x < this.min.x)\r\n                this.min.x = vertex.x;\r\n            if (vertex.y > this.max.y)\r\n                this.max.y = vertex.y;\r\n            if (vertex.y < this.min.y)\r\n                this.min.y = vertex.y;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Updates this bounds to contain a set of bounds.\r\n     * @param boundses The bounds.\r\n     */\r\n    envelop = (boundses: Bounds[], velocity?: Vec2) => {\r\n        this.min = Vec2.infinity;\r\n        this.max = Vec2.negativeInfinity;\r\n\r\n        // Iterate all bounds\r\n        for (const bounds of boundses) {\r\n            if (bounds.max.x > this.max.x)\r\n                this.max.x = bounds.max.x;\r\n            if (bounds.min.x < this.min.x)\r\n                this.min.x = bounds.min.x;\r\n            if (bounds.max.y > this.max.y)\r\n                this.max.y = bounds.max.y;\r\n            if (bounds.min.y < this.min.y)\r\n                this.min.y = bounds.min.y;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Determines if a point exists inside this bounds.\r\n     * @param point The point.\r\n     * @returns Whether the point exists inside this bounds.\r\n     */\r\n    contains = (point: Vec2) => point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y;\r\n\r\n    /**\r\n     * Determines if this bounds overlaps with another bounds.\r\n     * @param other The other bounds.\r\n     * @returns Whether the bounds overlap.\r\n     */\r\n    overlaps = (other: Bounds) => this.min.x <= other.max.x && this.max.x >= other.min.x && this.max.y >= other.min.y && this.min.y <= other.max.y;\r\n\r\n    /**\r\n     * Translates this bounds.\r\n     * @param v The translation vector.\r\n     * @returns This bounds after translating.\r\n     */\r\n    translate = (v: Vec2) => { this.min.translate(v); this.max.translate(v); return this; };\r\n\r\n    /**\r\n     * Scales this bounds.\r\n     * @param v The scale vector.\r\n     * @param origin The normalized origin to scale from.\r\n     * @returns This bounds after scaling.\r\n     */\r\n    scale = (v: Vec2, origin: Vec2 = Vec2.one.scale(0.5)) => {\r\n        const o = Vec2.lerpComponents(this.min, this.max, origin);\r\n        this.min.translate(Vec2.multiply(o, -1)).scaleComponents(v).translate(o);\r\n        this.max.translate(Vec2.multiply(o, -1)).scaleComponents(v).translate(o);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Shifts this bounds such that its origin is at a given position.\r\n     * @param pos The position.\r\n     * @param origin The normalized origin of the bounds.\r\n     * @returns This bounds after shifting.\r\n     */\r\n    shift = (pos: Vec2, origin: Vec2 = Vec2.one.scale(0.5)) => {\r\n        const o = Vec2.lerpComponents(this.min, this.max, origin);\r\n        return this.translate(Vec2.subtract(pos, o));\r\n    };\r\n\r\n    /**\r\n     * Extends this bounds by a vector.\r\n     * @param v The extension vector.\r\n     * @returns This bounds after extending.\r\n     */\r\n    extend = (v: Vec2) => {\r\n        if (v.x > 0) {\r\n            this.max.x += v.x;\r\n        } else {\r\n            this.min.x += v.x;\r\n        }\r\n        if (v.y > 0) {\r\n            this.max.y += v.y;\r\n        } else {\r\n            this.min.y += v.y;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** The zero bounds, [(0, 0), (0, 0)]. */\r\n    static get zero() { return new Bounds(Vec2.zero, Vec2.zero); }\r\n    /** The unit bounds, [(0, 0), (1, 1)]. */\r\n    static get unit() { return new Bounds(Vec2.zero, Vec2.one); }\r\n    /** The normalized bounds, [(-0.5, -0.5), (0.5, 0.5)]. */\r\n    static get norm() { return new Bounds(Vec2.one.scale(-0.5), Vec2.one.scale(0.5)); }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Collider from './Collider';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * A node that has a regular n-gon collider shape.\r\n */\r\nexport default class NgonCollider extends Collider {\r\n    private _sides: number = 3;\r\n    private _radius: number = 1;\r\n    private _vertices: Vec2[] = [];\r\n\r\n    /** The offset of the center of the collider. */\r\n    offset: Vec2 = Vec2.zero;\r\n\r\n    /** The number of sides of the polygon. */\r\n    get sides() { return this._sides; }\r\n    set sides(value: number) { this._sides = Math.max(value, 3); }\r\n\r\n    /** The radius of the polygon. */\r\n    get radius() { return this._radius; }\r\n    set radius(value: number) { this._radius = Math.max(value, 0); }\r\n\r\n    get vertices() { return this._vertices; }\r\n\r\n    regenerate() {\r\n        this._vertices = [];\r\n        for (let i = 0; i < this._sides; ++i) {\r\n            this._vertices.push(Vec2.fromAngle(360 * i / this._sides).scale(this._radius)\r\n                .scaleComponents(this.scale)\r\n                .rotate(this.rotation)\r\n                .translate(this.position)\r\n            );\r\n        }\r\n        this._bounds.fromVertices(this._vertices);\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Color from '../structures/Color';\r\nimport IDrawable from './IDrawable';\r\nimport Node from './Node'\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * A node that draws an image on the canvas.\r\n*/\r\nexport default class Sprite extends Node implements IDrawable {\r\n    private static bitmapStore: Map<string, ImageBitmap> = new Map<string, ImageBitmap>();\r\n    private static workingCanvas = new OffscreenCanvas(256, 256);\r\n\r\n    private _image: string | null = null;\r\n    private _color: Color = Color.white;\r\n    private bitmap: ImageBitmap | null = null;\r\n\r\n    /** The normalized pivot. */\r\n    pivot: Vec2 = Vec2.one.scale(0.5);\r\n\r\n    onDraw(context: CanvasRenderingContext2D): void {\r\n        if (this.bitmap) {\r\n            context.save();\r\n            context.translate(-this.pivot.x * this.bitmap.width, -this.pivot.y * this.bitmap.height);\r\n            context.drawImage(this.bitmap, 0, 0);\r\n            context.restore();\r\n        }\r\n    }\r\n\r\n    /** The image path. */\r\n    get image() { return this._image; }\r\n    set image(value: string | null) {\r\n        const changed = this._image !== value;\r\n        this._image = value;\r\n        if (changed) {\r\n            this.updateBitmap();\r\n        }\r\n    }\r\n\r\n    /** The color. */\r\n    get color() { return this._color; }\r\n    set color(value: Color) {\r\n        const changed = this._color !== value;\r\n        this._color = value;\r\n        if (changed) {\r\n            this.updateBitmap();\r\n        }\r\n    }\r\n\r\n    private async updateBitmap() {\r\n        if (this._image === null) {\r\n            this.bitmap = null;\r\n            return;\r\n        }\r\n        const bmp = await Sprite.load(this._image);\r\n        if (this.color.r == 1 && this.color.g == 1 && this.color.b == 1 && this.color.a == 1) {\r\n            this.bitmap = bmp;\r\n        }\r\n        else {\r\n            let data = Sprite.bitmapToData(bmp);\r\n            Sprite.colorise(data, this.color);\r\n            this.bitmap = Sprite.dataToBitmap(data);\r\n        }\r\n    }\r\n\r\n    private static load(path: string) {\r\n        if (Sprite.bitmapStore.has(path)) {\r\n            return new Promise<ImageBitmap>((resolve) => { resolve(Sprite.bitmapStore.get(path)!) });\r\n        }\r\n        return new Promise<ImageBitmap>((resolve) => {\r\n            let image = new Image();\r\n            image.onload = async () => {\r\n                let bmp = await createImageBitmap(image, 0, 0, image.width, image.height);\r\n                Sprite.bitmapStore.set(path, bmp);\r\n                image.remove();\r\n                resolve(bmp);\r\n            };\r\n            image.src = path;\r\n        });\r\n    }\r\n\r\n    private static unload(path: string) {\r\n        Sprite.bitmapStore.get(path)?.close();\r\n        Sprite.bitmapStore.delete(path);\r\n    }\r\n\r\n    private static bitmapToData(bmp: ImageBitmap) {\r\n        if (Sprite.workingCanvas.width < bmp.width) {\r\n            Sprite.workingCanvas.width = bmp.width;\r\n        }\r\n        if (Sprite.workingCanvas.height < bmp.height) {\r\n            Sprite.workingCanvas.height = bmp.height;\r\n        }\r\n        let ctx = Sprite.workingCanvas.getContext('2d', { willReadFrequently: true })!;\r\n        ctx.clearRect(0, 0, bmp.width, bmp.height);\r\n        ctx.drawImage(bmp, 0, 0);\r\n        return ctx.getImageData(0, 0, bmp.width, bmp.height);\r\n    }\r\n\r\n    private static dataToBitmap(dat: ImageData) {\r\n        if (Sprite.workingCanvas.width != dat.width) {\r\n            Sprite.workingCanvas.width = dat.width;\r\n        }\r\n        if (Sprite.workingCanvas.height != dat.height) {\r\n            Sprite.workingCanvas.height = dat.height;\r\n        }\r\n        let ctx = Sprite.workingCanvas.getContext('2d', { willReadFrequently: true })!;\r\n        ctx.clearRect(0, 0, dat.width, dat.height);\r\n        ctx.putImageData(dat, 0, 0);\r\n        return Sprite.workingCanvas.transferToImageBitmap();\r\n    }\r\n\r\n    private static colorise(img: ImageData, color: Color) {\r\n        for (let p = 0; p < img.data.length; p += 4) {\r\n            const [r, g, b] = [p, p + 1, p + 2];\r\n            img.data[r] *= color.r;\r\n            img.data[g] *= color.g;\r\n            img.data[b] *= color.b;\r\n        }\r\n    }\r\n}","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\n\r\n/**\r\n * Representation of a RGBA color.\r\n */\r\nexport default class Color implements ICopyable, IEquatable {\r\n    /** The red component. */\r\n    r: number = 0;\r\n    /** The green component. */\r\n    g: number = 0;\r\n    /** The blue component. */\r\n    b: number = 0;\r\n    /** The alpha component. */\r\n    a: number = 1;\r\n\r\n    constructor(r: number, g: number, b: number, a?: number) {\r\n        this.r = Math.clamp(r, 0, 1);\r\n        this.g = Math.clamp(g, 0, 1);\r\n        this.b = Math.clamp(b, 0, 1);\r\n        this.a = Math.clamp(a ?? 1, 0, 1);\r\n    }\r\n\r\n    copy = () => new Color(this.r, this.g, this.b, this.a);\r\n    copyFrom = (other: Color) => { this.r = other.r; this.g = other.g; this.b = other.b, this.a = other.a; return this; };\r\n    equals = (other: Color) => this.r == other.r && this.g == other.g && this.b == other.b && this.a == other.a;\r\n\r\n    /**\r\n     * Converts the color to its #RRGGBBAA hexadecimal string representation.\r\n     * @param hasAlpha Whether to include the alpha channel.\r\n     * @returns The hexadecimal string representation.\r\n     */\r\n    toHexString = (hasAlpha: boolean = false) => {\r\n        let str: string = \"#\";\r\n        str += ((this.r * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        str += ((this.g * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        str += ((this.b * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        if (hasAlpha) str += ((this.a * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * Converts the color to its HSV representation.\r\n     * @returns The HSV representation.\r\n     */\r\n    toHSV = () => {\r\n        const cmax = Math.max(this.r, this.g, this.b);\r\n        const cmin = Math.min(this.r, this.g, this.b);\r\n        const delta = cmax - cmin;\r\n        let [h, s, v] = [0, cmax === 0 ? 0 : delta / cmax, cmax];\r\n        if (cmax === this.r) {\r\n            h = Math.mod((this.g - this.b) / delta, 6);\r\n        }\r\n        else if (cmax === this.g) {\r\n            h = (this.g - this.b) / delta + 2;\r\n        }\r\n        else {\r\n            h = (this.g - this.b) / delta + 4;\r\n        }\r\n        return { h, s, v };\r\n    }\r\n\r\n    /** Black. */\r\n    static get black() { return new Color(0, 0, 0); }\r\n    /** Blue. */\r\n    static get blue() { return new Color(0, 0, 1); }\r\n    /** Green. */\r\n    static get green() { return new Color(0, 1, 0); }\r\n    /** Teal. */\r\n    static get teal() { return new Color(0, 1, 1); }\r\n    /** Red. */\r\n    static get red() { return new Color(1, 0, 0); }\r\n    /** Magenta. */\r\n    static get magenta() { return new Color(1, 0, 1); }\r\n    /** Yellow. */\r\n    static get yellow() { return new Color(1, 1, 0); }\r\n    /** White. */\r\n    static get white() { return new Color(1, 1, 1); }\r\n    /** Grey. */\r\n    static get grey() { return new Color(0.5, 0.5, 0.5); }\r\n    /** Transparent. */\r\n    static get transparent() { return new Color(0, 0, 0, 0); }\r\n\r\n    /**\r\n     * Linearly interpolates from one color to another.\r\n     * @param c1 The first color.\r\n     * @param c2 The second color.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated color.\r\n     */\r\n    static lerp(c1: Color, c2: Color, t: number) {\r\n        return new Color(\r\n            c1.r * (1 - t) + c2.r * t,\r\n            c1.g * (1 - t) + c2.g * t,\r\n            c1.b * (1 - t) + c2.b * t,\r\n            c1.a * (1 - t) + c2.a * t);\r\n    }\r\n\r\n    /**\r\n     * Spherically linearly interpolates from one color to another.\r\n     * @param c1 The first color.\r\n     * @param c2 The second color.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated color.\r\n     */\r\n    static slerp(c1: Color, c2: Color, t: number) {\r\n        const func = (t: number) => Math.sin(t * Math.PI / 2)\r\n        const [u, v] = [func(1 - t), func(t)];\r\n        return new Color(\r\n            c1.r * u + c2.r * v,\r\n            c1.g * u + c2.g * v,\r\n            c1.b * u + c2.b * v,\r\n            c1.a * u + c2.a * v);\r\n    }\r\n\r\n    /**\r\n     * Creates a color from its hexadecimal string representation.\r\n     * @param str The hexadecimal string representation.\r\n     * @returns The color.\r\n     */\r\n    static fromHexString = (str: string) => {\r\n        str = str.trim();\r\n        const r = parseInt(str.substring(1, 3), 16);\r\n        const g = parseInt(str.substring(3, 5), 16);\r\n        const b = parseInt(str.substring(5, 7), 16);\r\n        const a = str.length >= 7 ? parseInt(str.substring(7, 9), 16) : 255;\r\n        return new Color(r / 255, g / 255, b / 255, a / 255);\r\n    }\r\n\r\n    /**\r\n     * Creates a color from its HSV representation.\r\n     * @param h The hue.\r\n     * @param s The saturation.\r\n     * @param v The value.\r\n     * @returns The color.\r\n     */\r\n    static fromHSV = (h: number, s: number, v: number) => {\r\n        h = h * 360;\r\n        const c = s * v;\r\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1));\r\n        const m = v - c;\r\n        let [r, g, b] = [0, 0, 0];\r\n        if (h < 60) {\r\n            [r, g, b] = [c, x, 0];\r\n        }\r\n        else if (h < 120) {\r\n            [r, g, b] = [x, c, 0];\r\n        }\r\n        else if (h < 180) {\r\n            [r, g, b] = [0, c, x];\r\n        }\r\n        else if (h < 240) {\r\n            [r, g, b] = [0, x, c];\r\n        }\r\n        else if (h < 300) {\r\n            [r, g, b] = [x, 0, c];\r\n        }\r\n        else {\r\n            [r, g, b] = [c, 0, x];\r\n        }\r\n        return new Color(r + m, g + m, b + m);\r\n    }\r\n}"],"names":[],"version":3,"file":"Petrallengine.mjs.map"}