{"mappings":"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","sources":["src/Petrallengine.ts","src/Snowflake.ts","src/Game.ts","src/nodes/IDrawable.ts","src/nodes/IDebugDrawable.ts","src/nodes/Body.ts","src/nodes/Node.ts","src/structures/Vec2.ts","src/Math.ts","src/structures/Mat3.ts","src/nodes/Collider.ts","src/structures/Bounds.ts","src/systems/Camera.ts","src/systems/Input.ts","src/systems/Physics.ts","src/nodes/CircleCollider.ts","src/nodes/ConvexCollider.ts","src/nodes/CollisionBody.ts","src/nodes/Sprite.ts","src/structures/Color.ts"],"sourcesContent":["/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nexport * from \"./Snowflake\";\r\nexport { default as Game } from \"./Game\";\r\nexport { type default as IDrawable } from \"./nodes/IDrawable\";\r\nexport { default as Body } from \"./nodes/Body\";\r\nexport { default as CircleCollider } from \"./nodes/CircleCollider\";\r\nexport { default as Collider } from \"./nodes/Collider\";\r\nexport { default as CollisionBody } from \"./nodes/CollisionBody\";\r\nexport { default as Node } from \"./nodes/Node\";\r\nexport { default as Sprite } from \"./nodes/Sprite\";\r\nexport { default as Bounds } from \"./structures/Bounds\";\r\nexport { default as Color } from \"./structures/Color\";\r\nexport { type default as ICopyable } from \"./structures/ICopyable\";\r\nexport { type default as IEquatable } from \"./structures/IEquatable\";\r\nexport { default as Mat3 } from \"./structures/Mat3\";\r\nexport { default as Vec2 } from \"./structures/Vec2\";\r\nexport { default as Camera } from \"./systems/Camera\";\r\nexport { default as Input } from \"./systems/Input\";\r\nexport { default as Physics } from \"./systems/Physics\";\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\n// Adds two arrays for the given base (10 or 16), returning the result.\r\n// This turns out to be the only \"primitive\" operation we need.\r\nfunction add(x: number[], y: number[], base: number) {\r\n    let z: number[] = [];\r\n    let n = Math.max(x.length, y.length);\r\n    let carry = 0;\r\n    let i = 0;\r\n    while (i < n || carry) {\r\n        let xi = i < x.length ? x[i] : 0;\r\n        let yi = i < y.length ? y[i] : 0;\r\n        let zi = carry + xi + yi;\r\n        z.push(zi % base);\r\n        carry = Math.floor(zi / base);\r\n        i++;\r\n    }\r\n    return z;\r\n}\r\n\r\n// Returns a*x, where x is an array of decimal digits and a is an ordinary\r\n// JavaScript number. base is the number base of the array x.\r\nfunction multiplyByNumber(num: number, x: number[], base: number) {\r\n    if (num < 0 || num == 0) return [];\r\n\r\n    let result: number[] = [];\r\n    let power = x;\r\n    while (true) {\r\n        if (num & 1) {\r\n            result = add(result, power, base);\r\n        }\r\n        num = num >> 1;\r\n        if (num === 0) break;\r\n        power = add(power, power, base);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction parseToDigitsArray(str: string, base: number) {\r\n    let digits = str.split('');\r\n    let ary: number[] = [];\r\n    for (let i = digits.length - 1; i >= 0; i--) {\r\n        let n = parseInt(digits[i], base);\r\n        if (isNaN(n)) return null;\r\n        ary.push(n);\r\n    }\r\n    return ary;\r\n}\r\n\r\nfunction convertBase(str: string, fromBase: number, toBase: number) {\r\n    let digits = parseToDigitsArray(str, fromBase);\r\n    if (digits === null) return null;\r\n\r\n    let outArray: number[] = [];\r\n    let power = [1];\r\n    for (let i = 0; i < digits.length; i++) {\r\n        // invariant: at this point, fromBase^i = power\r\n        if (digits[i]) {\r\n            outArray = add(outArray, multiplyByNumber(digits[i], power, toBase), toBase);\r\n        }\r\n        power = multiplyByNumber(fromBase, power, toBase);\r\n    }\r\n\r\n    let out = '';\r\n    for (let i = outArray.length - 1; i >= 0; i--) {\r\n        out += outArray[i].toString(toBase);\r\n    }\r\n    return out;\r\n}\r\n\r\nfunction decToHex(decStr: string) {\r\n    let hex = convertBase(decStr, 10, 16);\r\n    return hex ? '0x' + hex : null;\r\n}\r\n\r\nfunction hexToDec(hexStr: string) {\r\n    if (hexStr.substring(0, 2) === '0x') hexStr = hexStr.substring(2);\r\n    hexStr = hexStr.toLowerCase();\r\n    return convertBase(hexStr, 16, 10);\r\n}\r\n\r\n/**\r\n * A Snowflake ID.\r\n */\r\nexport type Snowflake = string;\r\n\r\nclass SnowflakeFactory {\r\n    private static readonly TIME_BYTES = 4;\r\n    private static readonly RANDOM_BYTES = 2;\r\n    private static readonly INCREMENT_BYTES = 2;\r\n\r\n    private static increment = 0;\r\n\r\n    static make = () => {\r\n        let id = \"\";\r\n        id += Date.now().toString(16).slice(-SnowflakeFactory.TIME_BYTES * 2).padStart(SnowflakeFactory.TIME_BYTES * 2, '0');\r\n        id += Math.round(Math.random() * Math.pow(256, SnowflakeFactory.RANDOM_BYTES)).toString(16).padStart(SnowflakeFactory.RANDOM_BYTES * 2, '0');\r\n        id += SnowflakeFactory.inc.toString(16).padStart(SnowflakeFactory.INCREMENT_BYTES * 2, '0');\r\n        return id;\r\n    }\r\n\r\n    private static get inc() {\r\n        const lim = Math.pow(256, SnowflakeFactory.INCREMENT_BYTES);\r\n        if (++SnowflakeFactory.increment >= lim) { SnowflakeFactory.increment -= lim; }\r\n        return SnowflakeFactory.increment;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a unique Snowflake ID.\r\n * @returns A unique Snowflake ID.\r\n */\r\nexport const makeSnowflake: () => Snowflake = SnowflakeFactory.make;\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport { isDrawable } from './nodes/IDrawable';\r\nimport { isDebugDrawable } from './nodes/IDebugDrawable';\r\nimport Body from './nodes/Body';\r\nimport Collider from './nodes/Collider';\r\nimport Node from './nodes/Node';\r\nimport Camera from './systems/Camera';\r\nimport Input from './systems/Input';\r\nimport Physics from './systems/Physics';\r\n\r\n/**\r\n * Static class for Petrallengine.\r\n * \r\n * Call `Petrallengine.create(MY_CANVAS_ELEMENT)` to start building your 2D browser application.\r\n */\r\nexport default class Game {\r\n    /** The build number. */\r\n    static readonly BUILD = 1;\r\n    /** The version. */\r\n    static readonly VERSION = \"0.0.1\";\r\n    /** The number of scheduled frame updates per second. */\r\n    static readonly FRAME_RATE = 60;\r\n    /** The scheduled interval between frame updates in seconds. */\r\n    static readonly FRAME_TIME = 1 / Game.FRAME_RATE;\r\n    /** Debug draw flags. */\r\n    static readonly DEBUG_DRAWS = {\r\n        colliders: true,\r\n        boundingBoxes: true,\r\n    };\r\n\r\n    private static _deltaTime = Game.FRAME_TIME;\r\n    private static _time = 0;\r\n    private static rootNode: Node = new Node(Game, \"_ROOT_\");\r\n\r\n    /** The root node of the whole game. */\r\n    static get root() {\r\n        return Game.rootNode;\r\n    }\r\n\r\n    /**\r\n     * Initialises the engine.\r\n     * @param target The target canvas element to render onto.\r\n     */\r\n    static create(target?: HTMLCanvasElement) {\r\n        console.debug(`%cPetrallengine v${Game.VERSION}\\nby Petraller`, 'color: #0799ce');\r\n        console.debug(`https://petraller.com/`);\r\n\r\n        // Fallback target\r\n        if (!target) {\r\n            const targetDefaultID = 'app';\r\n            console.debug(`No canvas provided, using default target canvas #${targetDefaultID}`);\r\n\r\n            const ele = document.getElementById(targetDefaultID);\r\n            if (!ele || !(ele instanceof HTMLCanvasElement)) {\r\n                console.error(`Unable to find a canvas with ID #${targetDefaultID}`);\r\n                console.error(`Please create a canvas element with ID #${targetDefaultID}, or provide your own canvas to Petrallengine.create`);\r\n                return;\r\n            }\r\n\r\n            target = ele as HTMLCanvasElement;\r\n        }\r\n\r\n        console.debug(`Using ${target.outerHTML} as render canvas`);\r\n\r\n        // Initialise systems\r\n        const input = new Input(target);\r\n        const physics = new Physics();\r\n\r\n        // Get context\r\n        const canvas = target;\r\n        const context = canvas.getContext('2d')!;\r\n\r\n        // Create game loop\r\n        const ft = 1000 / Game.FRAME_RATE;\r\n        const gameLoop = () => {\r\n            const tStart = Date.now();\r\n\r\n            // Update all\r\n            function update(node: Node) {\r\n                if (!node.isEnabled)\r\n                    return;\r\n\r\n                if (!node.isStarted) {\r\n                    node.onStart?.call(node);\r\n                    node.isStarted = true;\r\n\r\n                    if (node instanceof Body) {\r\n                        Physics.registerBody(node);\r\n                    }\r\n                    if (node instanceof Collider) {\r\n                        let curr: Node | null = node.parent;\r\n                        while (curr !== null) {\r\n                            if (curr instanceof Body) {\r\n                                Physics.registerCollider(node, curr);\r\n                                break;\r\n                            }\r\n                            curr = curr.parent;\r\n                        }\r\n                        if (curr === null) {\r\n                            console.error(`Collider does not have a parent Body, it will not be registered by the Physics system`);\r\n                        }\r\n                    }\r\n                }\r\n                node.onUpdate?.call(node);\r\n                node.globalTransform;\r\n\r\n                // Iterate children\r\n                for (let child of node.children) {\r\n                    update(child);\r\n                }\r\n            }\r\n            update(Game.rootNode);\r\n\r\n            // Physics step\r\n            physics.tick();\r\n\r\n            // Reset\r\n            context.reset();\r\n\r\n            // Clear\r\n            context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n            // Apply camera transforms\r\n            context.translate(canvas.width / 2, canvas.height / 2);\r\n            context.translate(-Camera.position.x, -Camera.position.y);\r\n            context.rotate(-Camera.rotation * Math.PI / 180);\r\n            context.scale(Camera.scale.x, Camera.scale.y);\r\n\r\n            // Draw all\r\n            function draw(node: Node) {\r\n                if (!node.isEnabled)\r\n                    return;\r\n\r\n                // Draw drawables\r\n                if (isDrawable(node)) {\r\n                    context.save();\r\n\r\n                    // Apply node transforms\r\n                    context.transform(\r\n                        node.globalTransform.get(0, 0), node.globalTransform.get(1, 0),\r\n                        node.globalTransform.get(0, 1), node.globalTransform.get(1, 1),\r\n                        node.globalTransform.get(0, 2), node.globalTransform.get(1, 2)\r\n                    );\r\n\r\n                    node.onDraw.call(node, context);\r\n\r\n                    context.restore();\r\n                }\r\n\r\n                // Iterate children\r\n                for (let child of node.children) {\r\n                    draw(child);\r\n                }\r\n            }\r\n            draw(Game.rootNode);\r\n\r\n            // Debug draw\r\n            function debugDraw(node: Node) {\r\n                if (!node.isEnabled)\r\n                    return;\r\n\r\n                // // Draw colliders\r\n                // if (isCollider(node)) {\r\n                //     // Draw debug\r\n                //     node.debugDraw(context);\r\n                // }\r\n\r\n                // Draw drawables\r\n                if (isDebugDrawable(node)) {\r\n                    context.save();\r\n\r\n                    node.onDebugDraw.call(node, context);\r\n\r\n                    context.restore();\r\n                }\r\n\r\n                // Iterate children\r\n                for (let child of node.children) {\r\n                    debugDraw(child);\r\n                }\r\n            }\r\n            debugDraw(Game.rootNode);\r\n\r\n            // Clear transition flags\r\n            input.endFrame();\r\n\r\n            const tEnd = Date.now();\r\n            const dt = tEnd - tStart;\r\n            const wait = Math.max(ft - dt, 0);\r\n            Game._time += (Game._deltaTime = dt + wait);\r\n            setTimeout(gameLoop, wait);\r\n        };\r\n        gameLoop();\r\n    }\r\n\r\n    /**\r\n     * Returns the total elapsed game time in seconds.\r\n     */\r\n    static get time() {\r\n        return Game._time / 1000;\r\n    }\r\n\r\n    /**\r\n     * Returns the actual elapsed time for the frame in seconds.\r\n     */\r\n    static get deltaTime() {\r\n        return Game._deltaTime / 1000;\r\n    }\r\n};\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\n/**\r\n * Checks if an object implements a drawable.\r\n * @param obj The object.\r\n * @returns Whether the object implements a drawable.\r\n */\r\nexport function isDrawable(obj: Object): obj is IDrawable {\r\n    return 'onDraw' in obj && obj.onDraw instanceof Function;\r\n}\r\n\r\n/**\r\n * Interface for all drawables.\r\n */\r\nexport default interface IDrawable {\r\n    /**\r\n     * Called when drawn.\r\n     * @param context The canvas rendering context.\r\n     */\r\n    onDraw(context: CanvasRenderingContext2D): void;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\n/**\r\n * Checks if an object implements a debug drawable.\r\n * @param obj The object.\r\n * @returns Whether the object implements a debug drawable.\r\n */\r\nexport function isDebugDrawable(obj: Object): obj is IDebugDrawable {\r\n    return 'onDebugDraw' in obj && obj.onDebugDraw instanceof Function;\r\n}\r\n\r\n/**\r\n * Interface for all drawables.\r\n */\r\nexport default interface IDebugDrawable {\r\n    /**\r\n     * Called when debug drawn.\r\n     * @param context The canvas rendering context.\r\n     */\r\n    onDebugDraw(context: CanvasRenderingContext2D): void;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Node from './Node';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * Base class for all physics-based nodes.\r\n * \r\n * Overrideable callbacks:\r\n * - onCollisionEnter\r\n * - onCollisionUpdate\r\n * - onCollisionExit\r\n */\r\nexport default abstract class Body extends Node {\r\n    private _velocity: Vec2 = Vec2.zero;\r\n\r\n    /** The velocity of this body. */\r\n    get velocity() { return this._velocity; }\r\n    set velocity(value: Vec2) { this._velocity = value; }\r\n\r\n    /**\r\n     * Called when the node first collides with another body.\r\n     * @param other The colliding body.\r\n     */\r\n    onCollisionEnter?(other: Body): void;\r\n\r\n    /**\r\n     * Called while the node is colliding with another body.\r\n     * @param other The colliding body.\r\n     */\r\n    onCollisionUpdate?(other: Body): void;\r\n\r\n    /**\r\n     * Called when the node stops colliding with another body.\r\n     * @param other The colliding body.\r\n     */\r\n    onCollisionExit?(other: Body): void;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport { Snowflake, makeSnowflake } from '../Snowflake';\r\nimport Vec2 from '../structures/Vec2';\r\nimport Mat3 from '../structures/Mat3';\r\n\r\nexport type Constructor<T> = { new(...args: any[]): T };\r\n\r\n/**\r\n * Base class for all nodes in the scene tree.\r\n * \r\n * Overrideable callbacks:\r\n * - onCreate\r\n * - onStart\r\n * - onDestroy\r\n * - onEnable\r\n * - onDisable\r\n * - onUpdate\r\n */\r\nexport default class Node {\r\n    private _isEnabled: boolean = true;\r\n    private _position: Vec2 = Vec2.zero;\r\n    private _rotation: number = 0;\r\n    private _scale: Vec2 = Vec2.one;\r\n    private _parent: Node | null = null;\r\n    private _transform: Mat3 = Mat3.identity;\r\n    private _globalTransform: Mat3 = Mat3.identity;\r\n    private _isDirty = false;\r\n\r\n    /** The unique Snowflake ID of this node. */\r\n    readonly id: Snowflake = makeSnowflake();\r\n\r\n    /** The name of this node. */\r\n    name: string = \"New Node\";\r\n    /** The children nodes of this node. */\r\n    children: Node[] = [];\r\n    /** Whether this node has started. */\r\n    isStarted: boolean = false;\r\n\r\n    /**\r\n     * Avoid calling `new Node`, call `Petrallengine.root.createChild` instead.\r\n     */\r\n    constructor(flag?: any, name: string = \"New Node\") {\r\n        if (!flag) {\r\n            console.warn(`Avoid calling \\`new Node\\`, call \\`Petrallengine.root.createChild\\` instead`);\r\n            console.trace(`\\`new Node\\` call occured here:`);\r\n        }\r\n        this.name = name;\r\n    }\r\n\r\n    toString() { return `${this.name}#${this.id}`; }\r\n\r\n    /** The enabled state of this node. */\r\n    get isEnabled() { return this._isEnabled; }\r\n    set isEnabled(value: boolean) {\r\n        this._isEnabled = value;\r\n        if (value) {\r\n            this.onEnable?.call(this);\r\n        }\r\n        else {\r\n            this.onDisable?.call(this);\r\n        }\r\n    }\r\n\r\n    /** The position of this node. */\r\n    get position() { return this._position; }\r\n    set position(value: Vec2) { this._position = value; this._isDirty = true; }\r\n\r\n    /** The global position of this node. */\r\n    get globalPosition() { return this.globalTransform.translation; }\r\n    set globalPosition(value: Vec2) {\r\n        const parent = this.parent ? this.parent.globalTransform : Mat3.identity;\r\n        const parentInverse = Mat3.inverse(parent);\r\n        const local = Mat3.matrixMultiply(parentInverse, Mat3.makeTransformation(value, this._rotation, this._scale));\r\n        this.position = local.translation;\r\n    }\r\n\r\n    /** The rotation in degrees of this node. */\r\n    get rotation() { return this._rotation; }\r\n    set rotation(value: number) { this._rotation = (value + 180) % 360 - 180; this._isDirty = true; }\r\n\r\n    /** The global rotation in degrees of this node. */\r\n    get globalRotation() {\r\n        let rot = this._rotation;\r\n        let curr = this._parent;\r\n        while (curr !== null) {\r\n            rot += curr._rotation;\r\n            curr = curr._parent;\r\n        }\r\n        return rot;\r\n    }\r\n    set globalRotation(value: number) {\r\n        let rot = 0;\r\n        let curr = this._parent;\r\n        while (curr !== null) {\r\n            rot += curr._rotation;\r\n            curr = curr._parent;\r\n        }\r\n        this.rotation = value - rot;\r\n    }\r\n\r\n    /** The scale of this node. */\r\n    get scale() { return this._scale; }\r\n    set scale(value: Vec2) { this._scale = value; this._isDirty = true; }\r\n\r\n    /** The global scale of this node. */\r\n    get globalScale() { return this.globalTransform.scale; }\r\n\r\n    /** The transformation matrix of this node. */\r\n    get transform() { this.recalculateTransformMatrix(); return this._transform; }\r\n\r\n    /** The global transformation matrix of this node. */\r\n    get globalTransform() { this.recalculateTransformMatrix(); return this._globalTransform; }\r\n\r\n    /** The parent node of this node. */\r\n    get parent() { return this._parent; }\r\n    set parent(value: Node | null) {\r\n        if (value && value.isDescendantOf(this)) {\r\n            // Hey stop that. No circular hierarchy pls\r\n            console.error(`Making \\`${value.toString()}\\` a parent of \\`${this.toString()}\\` will create a circular hierarchy`);\r\n            return;\r\n        }\r\n        if (this._parent) {\r\n            const i = this._parent.children.indexOf(this);\r\n            if (i !== -1) {\r\n                this._parent.children.splice(i, 1);\r\n            }\r\n        }\r\n        this._parent = value;\r\n        if (this._parent) {\r\n            this._parent.children.push(this);\r\n        }\r\n    }\r\n\r\n    /** The sibling index of this node. */\r\n    get siblingIndex() {\r\n        if (!this._parent)\r\n            return 0;\r\n        return this._parent.children.indexOf(this);\r\n    }\r\n    set siblingIndex(value: number) {\r\n        if (!this._parent)\r\n            return;\r\n        const i = this.siblingIndex;\r\n        this._parent.children.splice(i, 1);\r\n        this._parent.children.splice(value, 0, this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new child node of this node.\r\n     * @returns The child node.\r\n     */\r\n    createChild<T extends Node>(type: Constructor<T>) {\r\n        const node = new type(this.createChild);\r\n        node.parent = this;\r\n        node.onCreate?.call(node);\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Destroys this node and all children nodes.\r\n     */\r\n    destroy() {\r\n        for (let child of this.children) {\r\n            child.destroy();\r\n        }\r\n        this.onDestroy?.call(this);\r\n        this.parent = null;\r\n    }\r\n\r\n    /**\r\n     * Finds a descendant node by its name.\r\n     * @param name The name of the node.\r\n     * @returns The node, or null if not found.\r\n     */\r\n    findDescendantByName(name: string): Node | null {\r\n        for (let child of this.children) {\r\n            if (child.name == name)\r\n                return child;\r\n        }\r\n        for (let child of this.children) {\r\n            const result = child.findDescendantByName(name);\r\n            if (result)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Finds a descendant node by its type.\r\n     * @param type The type of the node.\r\n     * @returns The node, or null if not found.\r\n     */\r\n    findDescendantByType<T>(type: Constructor<T>): T | null {\r\n        for (let child of this.children) {\r\n            if (child instanceof type)\r\n                return child;\r\n        }\r\n        for (let child of this.children) {\r\n            const result = child.findDescendantByType(type);\r\n            if (result)\r\n                return result;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Determines if this node is a descendent of another node.\r\n     * @param node The other node.\r\n     * @returns Whether this node is a descendant.\r\n     */\r\n    isDescendantOf(node: Node) {\r\n        let curr = this.parent;\r\n        while (curr !== null) {\r\n            if (curr === node)\r\n                return true;\r\n            curr = curr.parent;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Recalculates the transformation matrices and unsets the dirty flag.\r\n     */\r\n    private recalculateTransformMatrix() {\r\n        if (!this._isDirty)\r\n            return;\r\n\r\n        // Calculate\r\n        this._transform = Mat3.makeTransformation(this._position, this._rotation, this._scale);\r\n        if (this.parent)\r\n            this._globalTransform = Mat3.matrixMultiply(this.parent.globalTransform, this._transform);\r\n        else\r\n            this._globalTransform = this._transform.copy();\r\n\r\n        // Dirty children\r\n        for (const child of this.children) {\r\n            child._isDirty = true;\r\n        }\r\n\r\n        this._isDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Called when the node is created.\r\n     */\r\n    onCreate?(): void;\r\n\r\n    /**\r\n     * Called when the node is first ticked.\r\n     */\r\n    onStart?(): void;\r\n\r\n    /**\r\n     * Called when the node is destroyed.\r\n     */\r\n    onDestroy?(): void;\r\n\r\n    /**\r\n     * Called when the node is enabled.\r\n     */\r\n    onEnable?(): void;\r\n\r\n    /**\r\n     * Called when the node is disabled.\r\n     */\r\n    onDisable?(): void;\r\n\r\n    /**\r\n     * Called when the node is ticked.\r\n     */\r\n    onUpdate?(): void;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\nimport Mat3 from './Mat3';\r\n\r\n/**\r\n * Representation of a 2D vector.\r\n */\r\nexport default class Vec2 implements ICopyable, IEquatable {\r\n    private _x: number = 0;\r\n    private _y: number = 0;\r\n\r\n    constructor(x: number, y: number) {\r\n        this._x = x;\r\n        this._y = y;\r\n    }\r\n\r\n    copy = () => new Vec2(this.x, this.y);\r\n    copyFrom = (other: Vec2) => { this._x = other.x; this._y = other.y; return this; };\r\n    equals = (other: Vec2) => this.x === other.x && this.y === other.y;\r\n\r\n    /** The x-component. */\r\n    get x() { return this._x; }\r\n\r\n    /** The y-component. */\r\n    get y() { return this._y; }\r\n\r\n    /** The squared length of this vector. */\r\n    get sqrLength() { return this.x * this.x + this.y * this.y; }\r\n\r\n    /** The length of this vector. */\r\n    get length() { return Math.sqrt(this.sqrLength); }\r\n\r\n    /** The normalized form of this vector. */\r\n    get normalized() { const l = this.length; return l == 0 ? Vec2.zero : Vec2.divide(this, l); };\r\n\r\n    /** A normal to this vector. */\r\n    get normal() { return new Vec2(-this.y, this.x); };\r\n\r\n    /** The value of the minimum component of this vector. */\r\n    get minComponent() { return this.x < this.y ? this.x : this.y; }\r\n\r\n    /** The value of the maximum component of this vector. */\r\n    get maxComponent() { return this.x > this.y ? this.x : this.y; }\r\n\r\n    /** The zero vector. */\r\n    static get zero() { return new Vec2(0, 0); }\r\n    /** The unit vector. */\r\n    static get one() { return new Vec2(1, 1); }\r\n    /** The right vector. */\r\n    static get right() { return new Vec2(1, 0); }\r\n    /** The left vector. */\r\n    static get left() { return new Vec2(-1, 0); }\r\n    /** The down vector. */\r\n    static get down() { return new Vec2(0, 1); }\r\n    /** The up vector. */\r\n    static get up() { return new Vec2(0, -1); }\r\n    /** The negative infinity vector. */\r\n    static get negativeInfinity() { return new Vec2(-Infinity, -Infinity); }\r\n    /** The infinity vector. */\r\n    static get infinity() { return new Vec2(Infinity, Infinity); }\r\n\r\n    /**\r\n     * Adds two vectors component-wise.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The sum vector.\r\n     */\r\n    static add = (v1: Vec2, v2: Vec2) => new Vec2(v1.x + v2.x, v1.y + v2.y);\r\n\r\n    /**\r\n     * Multiplies a vector by a constant.\r\n     * @param v The vector.\r\n     * @param n The constant\r\n     * @returns The scaled vector.\r\n     */\r\n    static multiply = (v: Vec2, n: number) => new Vec2(v.x * n, v.y * n);\r\n\r\n    /**\r\n     * Multiplies two vectors component-wise.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The scaled vector.\r\n     */\r\n    static multiplyComponents = (v1: Vec2, v2: Vec2) => new Vec2(v1.x * v2.x, v1.y * v2.y);\r\n\r\n    /**\r\n     * Subtracts one vector from another.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The difference vector.\r\n     */\r\n    static subtract = (v1: Vec2, v2: Vec2) => Vec2.add(v1, Vec2.multiply(v2, -1));\r\n\r\n    /**\r\n     * Divides a vector by a constant.\r\n     * @param v The vector.\r\n     * @param n The constant.\r\n     * @returns The scaled vector.\r\n     */\r\n    static divide = (v: Vec2, n: number) => Vec2.multiply(v, 1 / n);\r\n\r\n    /**\r\n     * Inverts a vector component-wise.\r\n     * @param v The vector.\r\n     * @returns The inverted vector.\r\n     */\r\n    static inverse = (v: Vec2) => new Vec2(1 / v.x, 1 / v.y);\r\n\r\n    /**\r\n     * Dot multiplies two vectors.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The dot product.\r\n     */\r\n    static dot = (v1: Vec2, v2: Vec2) => v1.x * v2.x + v1.y * v2.y;\r\n\r\n    /**\r\n     * Cross multiplies two vectors.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @returns The magnitude of the cross product.\r\n     */\r\n    static cross = (v1: Vec2, v2: Vec2) => v1.x * v2.y - v1.y * v2.x;\r\n\r\n    /**\r\n     * Rotates a vector by an angle.\r\n     * @param deg The angle in degrees.\r\n     * @returns The rotated vector.\r\n     */\r\n    static rotate = (v: Vec2, deg: number) => {\r\n        const r = deg * Math.PI / 180;\r\n        const x = Math.cos(r) * v.x - Math.sin(r) * v.y;\r\n        const y = Math.sin(r) * v.x + Math.cos(r) * v.y;\r\n        return new Vec2(x, y);\r\n    };\r\n\r\n    /**\r\n     * Transforms a vector by a matrix.\r\n     * @param m The matrix.\r\n     * @param v The vector.\r\n     * @returns The transformed vector.\r\n     */\r\n    static transform = (m: Mat3, v: Vec2) => {\r\n        const x = v.x * m.get(0, 0) + v.y * m.get(0, 1) + m.get(0, 2);\r\n        const y = v.x * m.get(1, 0) + v.y * m.get(1, 1) + m.get(1, 2);\r\n        return new Vec2(x, y);\r\n    };\r\n\r\n    /**\r\n     * Converts an angle in degrees to a unit vector.\r\n     * @param deg The angle in degrees.\r\n     * @returns The vector.\r\n     */\r\n    static fromAngle = (deg: number) => { const r = deg * Math.PI / 180; return new Vec2(Math.cos(r), Math.sin(r)); };\r\n\r\n    /**\r\n     * Converts a vector to its angle from the x-axis.\r\n     * @param v The vector.\r\n     * @returns The angle in degrees.\r\n     */\r\n    static toAngle = (v: Vec2) => {\r\n        if (v.x == 0)\r\n            return v.y >= 0 ? 90 : -90;\r\n        return (v.x > 0 ? 0 : (v.y > 0 ? 180 : -180)) + Math.atan(v.y / v.x) * 180 / Math.PI;\r\n    }\r\n\r\n    /**\r\n     * Converts an arbitrary object with x and y properties to a vector.\r\n     * @param obj The object.\r\n     * @returns The vector.\r\n     */\r\n    static fromObjXY = (obj: { x: number, y: number }) => new Vec2(obj.x, obj.y);\r\n\r\n    /**\r\n     * Converts an arbitrary object with width and height properties to a vector.\r\n     * @param obj The object.\r\n     * @returns The vector.\r\n     */\r\n    static fromObjWH = (obj: { width: number, height: number }) => new Vec2(obj.width, obj.height);\r\n\r\n    /**\r\n     * Converts a 3-tuple to a vector, omitting the last element of the tuple.\r\n     * @param obj The 3-tuple.\r\n     * @returns The vector.\r\n     */\r\n    static from3Tuple = (obj: [number, number, number]) => new Vec2(obj[0], obj[1]);\r\n\r\n    /**\r\n     * Linearly interpolates from one vector to another.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated vector.\r\n     */\r\n    static lerp = (v1: Vec2, v2: Vec2, t: number) => new Vec2(Math.lerp(v1.x, v2.x, t), Math.lerp(v1.y, v2.y, t));\r\n\r\n    /**\r\n     * Linearly interpolates from one vector to another.\r\n     * @param v1 The first vector.\r\n     * @param v2 The second vector.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated vector.\r\n     */\r\n    static lerpComponents = (v1: Vec2, v2: Vec2, t: Vec2) => new Vec2(Math.lerp(v1.x, v2.x, t.x), Math.lerp(v1.y, v2.y, t.y));\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\n/** */\r\ninterface Math {\r\n    /**\r\n     * Linearly interpolates from one value to another.\r\n     * @param x The first value.\r\n     * @param y The second value.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated value.\r\n     */\r\n    lerp(x: number, y: number, t: number): number;\r\n\r\n    /**\r\n     * Clamps a value between two values.\r\n     * @param x The value to clamp.\r\n     * @param min The minimum value.\r\n     * @param max The maximum value.\r\n     * @returns The clamped value.\r\n     */\r\n    clamp(x: number, min: number, max: number): number;\r\n\r\n    /**\r\n     * Performs a modified modulo operation on two numbers.\r\n     * \r\n     * The operation will yield the positive remainder of the dividend divided by the absolute value of the divisor.\r\n     * @param x The dividend.\r\n     * @param y The divisor.\r\n     * @returns The remainder.\r\n     */\r\n    mod(x: number, y: number): number;\r\n}\r\n\r\nMath.lerp = (x: number, y: number, t: number) => x * (1 - t) + y * t;\r\nMath.clamp = (x: number, min: number, max: number) => Math.min(Math.max(x, min), max);\r\nMath.mod = (x: number, y: number) => (x >= 0) ? (x % Math.abs(y)) : (Math.abs(y) - (-x % Math.abs((y))) % Math.abs(y));\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\nimport Vec2 from './Vec2';\r\n\r\ntype Row = [number, number, number];\r\ntype Column = [number, number, number];\r\ntype Matrix = [Row, Row, Row]; /* your boat */\r\n\r\n/**\r\n * Representation of a 3x3 matrix.\r\n */\r\nexport default class Mat3 implements ICopyable, IEquatable {\r\n    /** The matrix. */\r\n    private _m: Matrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\r\n\r\n    constructor(m?: Matrix) {\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                this._m[r][c] = m ? m[r][c] : 0;\r\n    }\r\n\r\n    copy = () => new Mat3(this._m);\r\n    copyFrom = (other: Mat3) => {\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                this._m[r][c] = other._m[r][c];\r\n        return this;\r\n    }\r\n    equals = (other: Mat3) => {\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                if (this._m[r][c] !== other._m[r][c])\r\n                    return false;\r\n        return true;\r\n    }\r\n\r\n    /** The determinant of this matrix. */\r\n    get determinant() {\r\n        return this._m[0][0] * (this._m[1][1] * this._m[2][2] - this._m[1][2] * this._m[2][1]) +\r\n            this._m[0][1] * (this._m[1][2] * this._m[2][0] - this._m[1][0] * this._m[2][2]) +\r\n            this._m[0][2] * (this._m[1][0] * this._m[2][1] - this._m[1][1] * this._m[2][0]);\r\n    }\r\n\r\n    /** The translation component of the matrix. */\r\n    get translation() { return Vec2.from3Tuple(this.getColumn(2)); }\r\n    set translation(value: Vec2) { this.set(0, 2, value.x).set(1, 2, value.y); }\r\n\r\n    /** The non-negative scale component of the matrix. */\r\n    get scale() { return new Vec2(Vec2.from3Tuple(this.getColumn(0)).length, Vec2.from3Tuple(this.getColumn(1)).length); }\r\n\r\n    /**\r\n     * Retrieves an element of the matrix.\r\n     * @param r The row index.\r\n     * @param c The column index.\r\n     * @returns The element.\r\n     */\r\n    get = (r: number, c: number) => this._m[r][c];\r\n\r\n    /**\r\n     * Sets an element of the matrix.\r\n     * @param r The row index.\r\n     * @param c The column index.\r\n     * @param value The value.\r\n     * @returns This matrix after setting.\r\n     */\r\n    set = (r: number, c: number, value: number) => { this._m[r][c] = value; return this; }\r\n\r\n    /**\r\n     * Retrieves a row of the matrix.\r\n     * @param r The row index.\r\n     * @returns The row.\r\n     */\r\n    getRow = (r: number): Row => [this._m[r][0], this._m[r][1], this._m[r][2]];\r\n\r\n    /**\r\n     * Retrieves a column of the matrix.\r\n     * @param c The column index.\r\n     * @returns The column.\r\n     */\r\n    getColumn = (c: number): Column => [this._m[0][c], this._m[1][c], this._m[2][c]];\r\n\r\n    /**\r\n     * Retrieves a minor of the matrix.\r\n     * @param r The row index to omit.\r\n     * @param c The column index to omit.\r\n     * @returns The minor.\r\n     */\r\n    private getMinor = (r: number, c: number): [[number, number], [number, number]] => [\r\n        r == 0\r\n            ? [c == 0 ? this._m[1][1] : this._m[1][0], c == 2 ? this._m[1][1] : this._m[1][2]]\r\n            : [c == 0 ? this._m[0][1] : this._m[0][0], c == 2 ? this._m[0][1] : this._m[0][2]],\r\n        r == 2\r\n            ? [c == 0 ? this._m[1][1] : this._m[1][0], c == 2 ? this._m[1][1] : this._m[1][2]]\r\n            : [c == 0 ? this._m[2][1] : this._m[2][0], c == 2 ? this._m[2][1] : this._m[2][2]]\r\n    ];\r\n\r\n    /**\r\n     * Retrieves the determinant of a cofactor of the matrix.\r\n     * @param r The row index of the element.\r\n     * @param c The column index of the element.\r\n     * @returns The determinant of the cofactor.\r\n     */\r\n    private getCofactorDeterminant = (r: number, c: number) => {\r\n        let minor = this.getMinor(r, c);\r\n        let i = (r + c) % 2 === 0 ? 1 : -1;\r\n        return i * (minor[0][0] * minor[1][1] - minor[1][0] * minor[0][1]);\r\n    }\r\n\r\n    /** The zero matrix. */\r\n    static get zero() { return new Mat3([[0, 0, 0], [0, 0, 0], [0, 0, 0]]); }\r\n    /** The identity matrix. */\r\n    static get identity() { return new Mat3([[1, 0, 0], [0, 1, 0], [0, 0, 1]]); }\r\n\r\n    /**\r\n     * Adds two matrices component-wise.\r\n     * \r\n     * Does not modify the original matrices.\r\n     * @param m1 The first matrix.\r\n     * @param m2 The second matrix.\r\n     * @returns The sum matrix.\r\n     */\r\n    static add = (m1: Mat3, m2: Mat3) => {\r\n        let result = new Mat3();\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                result._m[r][c] = m1._m[r][c] + m2._m[r][c];\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Multiplies a matrix by a constant.\r\n     * \r\n     * Does not modify the original matrix.\r\n     * @param m The matrix.\r\n     * @param n The constant\r\n     * @returns The scaled matrix.\r\n     */\r\n    static multiply = (m: Mat3, n: number) => {\r\n        let result = new Mat3();\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                result._m[r][c] = m._m[r][c] * n;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Multiplies two matrices.\r\n     * \r\n     * Does not modify the original matrices.\r\n     * @param m1 The first matrix.\r\n     * @param m2 The second matrix.\r\n     * @returns The multiplied matrix.\r\n     */\r\n    static matrixMultiply = (m1: Mat3, m2: Mat3) => {\r\n        let result = new Mat3();\r\n        for (let r = 0; r < 3; ++r)\r\n            for (let c = 0; c < 3; ++c)\r\n                for (let i = 0; i < 3; ++i)\r\n                    result._m[r][c] += m1._m[r][i] * m2._m[i][c];\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Subtracts one matrix from another.\r\n     * \r\n     * Does not modify the original matrices.\r\n     * @param m1 The first matrix.\r\n     * @param m2 The second matrix.\r\n     * @returns The difference matrix.\r\n     */\r\n    static subtract = (m1: Mat3, m2: Mat3) => Mat3.add(m1, Mat3.multiply(m2, -1));\r\n\r\n    /**\r\n     * Divides a matrix by a constant.\r\n     * \r\n     * Does not modify the original matrix.\r\n     * @param m The matrix.\r\n     * @param n The constant\r\n     * @returns The scaled matrix.\r\n     */\r\n    static divide = (m: Mat3, n: number) => Mat3.multiply(m, 1 / n);\r\n\r\n    /**\r\n     * Transposes a matrix.\r\n     * @param m The matrix.\r\n     * @returns The transposed matrix.\r\n     */\r\n    static transpose = (m: Mat3) => {\r\n        return new Mat3([\r\n            [m._m[0][0], m._m[1][0], m._m[2][0]],\r\n            [m._m[0][1], m._m[1][1], m._m[2][1]],\r\n            [m._m[0][2], m._m[1][2], m._m[2][2]]\r\n        ]);;\r\n    }\r\n\r\n    /**\r\n     * Inverts a matrix. If the matrix is not invertible, an error is thrown.\r\n     * \r\n     * Does not modify the original matrix.\r\n     * @param m The matrix.\r\n     * @returns The inverse matrix.\r\n     */\r\n    static inverse = (m: Mat3) => {\r\n        const det = m.determinant;\r\n        if (det === 0) {\r\n            console.error(`Matrix ${m._m} is not invertible`);\r\n            return m;\r\n        }\r\n        return Mat3.multiply(new Mat3([\r\n            [m.getCofactorDeterminant(0, 0), m.getCofactorDeterminant(1, 0), m.getCofactorDeterminant(2, 0)],\r\n            [m.getCofactorDeterminant(0, 1), m.getCofactorDeterminant(1, 1), m.getCofactorDeterminant(2, 1)],\r\n            [m.getCofactorDeterminant(0, 2), m.getCofactorDeterminant(1, 2), m.getCofactorDeterminant(2, 2)]\r\n        ]), 1 / det);\r\n    }\r\n\r\n    /**\r\n     * Constructs a translation matrix.\r\n     * @param v The translation vector.\r\n     * @returns The translation matrix.\r\n     */\r\n    static makeTranslation = (v: Vec2) => {\r\n        return Mat3.identity.set(0, 2, v.x).set(1, 2, v.y);\r\n    }\r\n\r\n    /**\r\n     * Constructs a rotation matrix.\r\n     * @param deg The rotation in degrees.\r\n     * @returns The rotation matrix.\r\n     */\r\n    static makeRotation = (deg: number) => {\r\n        const r = deg * Math.PI / 180;\r\n        return Mat3.identity\r\n            .set(0, 0, Math.cos(r)).set(0, 1, -Math.sin(r))\r\n            .set(1, 0, Math.sin(r)).set(1, 1, Math.cos(r));\r\n    }\r\n\r\n    /**\r\n     * Constructs a scaling matrix.\r\n     * @param v The scaling vector.\r\n     * @returns The scaling matrix.\r\n     */\r\n    static makeScaling = (v: Vec2) => {\r\n        return Mat3.identity.set(0, 0, v.x).set(1, 1, v.y);\r\n    }\r\n\r\n    /**\r\n     * Constructs a transformation matrix.\r\n     * @param t The translation vector.\r\n     * @param r The rotation in degrees.\r\n     * @param s The scaling vector.\r\n     * @returns The transformation matrix.\r\n     */\r\n    static makeTransformation = (t: Vec2, r: number, s: Vec2) => {\r\n        return Mat3.matrixMultiply(\r\n            Mat3.matrixMultiply(\r\n                Mat3.makeTranslation(t),\r\n                Mat3.makeRotation(r)\r\n            ), Mat3.makeScaling(s)\r\n        );\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport IDebugDrawable from './IDebugDrawable';\r\nimport Node from './Node';\r\nimport Bounds from '../structures/Bounds';\r\n\r\n/**\r\n * 32-bit bitmask used for collisions.\r\n */\r\nexport type Mask = number;\r\n\r\n/**\r\n * Base class for all collider nodes.\r\n * \r\n * A collider must have a parent PhysicsBody to detect collisions.\r\n */\r\nexport default abstract class Collider extends Node implements IDebugDrawable {\r\n    protected _bounds = Bounds.zero;\r\n\r\n    /** The layers this body is part of. */\r\n    layers: Mask = 0x00000001;\r\n    /** The layers this body can interact with. */\r\n    filter: Mask = 0x00000001;\r\n\r\n    /** The globally positioned bounds of this collider. */\r\n    get bounds() { return this._bounds.copy(); }\r\n\r\n    /**\r\n     * Regenerates the cached properties of the collider.\r\n     * \r\n     * Implementation defined by the collider subtype.\r\n     */\r\n    abstract regenerate(): void;\r\n\r\n    /**\r\n     * Determines if this collider can interact with another collider based on their layers.\r\n     * @param other The other collider.\r\n     * @returns Whether the colliders can interact.\r\n     */\r\n    canCollideWith(other: Collider) {\r\n        return ((other.layers & this.filter) !== 0);\r\n    }\r\n\r\n    onDebugDraw(context: CanvasRenderingContext2D): void {\r\n        // Draw bb\r\n        context.strokeStyle = \"#00ffff\";\r\n        context.strokeRect(\r\n            this._bounds.min.x,\r\n            this._bounds.min.y,\r\n            this._bounds.size.x,\r\n            this._bounds.size.y);\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\nimport Vec2 from './Vec2';\r\n\r\n/**\r\n * Representation of 2D bounds.\r\n */\r\nexport default class Bounds implements ICopyable, IEquatable {\r\n    /** The minimum components. */\r\n    min: Vec2 = Vec2.zero;\r\n    /** The maximum components. */\r\n    max: Vec2 = Vec2.zero;\r\n\r\n    constructor(min: Vec2, max: Vec2) {\r\n        this.min.copyFrom(min);\r\n        this.max.copyFrom(max);\r\n    }\r\n\r\n    copy = () => new Bounds(this.min, this.max);\r\n    copyFrom = (other: Bounds) => { this.min.copyFrom(other.min); this.max.copyFrom(other.max); return this; };\r\n    equals = (other: Bounds) => this.min.equals(other.min) && this.max.equals(other.max);\r\n\r\n    /** The size of the bounds. */\r\n    get size() { return Vec2.subtract(this.max, this.min); }\r\n\r\n    /**\r\n     * Determines if a point exists inside this bounds.\r\n     * @param point The point.\r\n     * @returns Whether the point exists inside this bounds.\r\n     */\r\n    contains = (point: Vec2) => point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y;\r\n\r\n    /**\r\n     * Determines if this bounds overlaps with another bounds.\r\n     * @param other The other bounds.\r\n     * @returns Whether the bounds overlap.\r\n     */\r\n    overlaps = (other: Bounds) => this.min.x <= other.max.x && this.max.x >= other.min.x && this.max.y >= other.min.y && this.min.y <= other.max.y;\r\n\r\n    /** The zero bounds, [(0, 0), (0, 0)]. */\r\n    static get zero() { return new Bounds(Vec2.zero, Vec2.zero); }\r\n    /** The unit bounds, [(0, 0), (1, 1)]. */\r\n    static get unit() { return new Bounds(Vec2.zero, Vec2.one); }\r\n    /** The normalized bounds, [(-0.5, -0.5), (0.5, 0.5)]. */\r\n    static get norm() { return new Bounds(Vec2.multiply(Vec2.one, -0.5), Vec2.multiply(Vec2.one, 0.5)); }\r\n\r\n    /**\r\n     * Create bounds based on a set of vertices.\r\n     * @param vertices The vertices.\r\n     * @returns The bounds.\r\n     */\r\n    static fromVertices = (vertices: Vec2[]) => {\r\n        let b = new Bounds(Vec2.infinity, Vec2.negativeInfinity);\r\n\r\n        // Iterate all vertices\r\n        for (const vertex of vertices) {\r\n            if (vertex.x > b.max.x) b.max = new Vec2(vertex.x, b.max.y);\r\n            if (vertex.x < b.min.x) b.min = new Vec2(vertex.x, b.min.y);\r\n            if (vertex.y > b.max.y) b.max = new Vec2(b.max.x, vertex.y);\r\n            if (vertex.y < b.min.y) b.min = new Vec2(b.min.x, vertex.y);\r\n        }\r\n        return b;\r\n    };\r\n\r\n    /**\r\n     * Create bounds that envelop a set of bounds.\r\n     * @param boundses The set of bounds to envelop.\r\n     * @returns The bounds.\r\n     */\r\n    static makeEnvelop = (boundses: Bounds[],) => {\r\n        let b = new Bounds(Vec2.infinity, Vec2.negativeInfinity);\r\n\r\n        // Iterate all bounds\r\n        for (const bounds of boundses) {\r\n            if (bounds.max.x > b.max.x) b.max = new Vec2(bounds.max.x, b.max.y);\r\n            if (bounds.min.x < b.min.x) b.min = new Vec2(bounds.min.x, b.min.y);\r\n            if (bounds.max.y > b.max.y) b.max = new Vec2(b.max.x, bounds.max.y);\r\n            if (bounds.min.y < b.min.y) b.min = new Vec2(b.min.x, bounds.min.y);\r\n        }\r\n        return b;\r\n    };\r\n\r\n    /**\r\n     * Translates bounds.\r\n     * @param b The bounds.\r\n     * @param v The translation vector.\r\n     * @returns The translated bounds.\r\n     */\r\n    static translate = (b: Bounds, v: Vec2) => { return new Bounds(Vec2.add(b.min, v), Vec2.add(b.max, v)); };\r\n\r\n    /**\r\n     * Scales bounds.\r\n     * @param b The bounds.\r\n     * @param v The scale vector.\r\n     * @param origin The normalized origin to scale from.\r\n     * @returns The scaled bounds.\r\n     */\r\n    static scale = (b: Bounds, v: Vec2, origin: Vec2 = Vec2.multiply(Vec2.one, 0.5)) => {\r\n        const o = Vec2.lerpComponents(b.min, b.max, origin);\r\n        return new Bounds(\r\n            Vec2.add(Vec2.multiplyComponents(Vec2.add(b.min, Vec2.multiply(o, -1)), v), o),\r\n            Vec2.add(Vec2.multiplyComponents(Vec2.add(b.max, Vec2.multiply(o, -1)), v), o)\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Shifts bounds such that its origin is at a given position.\r\n     * @param b The bounds.\r\n     * @param pos The position.\r\n     * @param origin The normalized origin of the bounds.\r\n     * @returns The shifted bounds.\r\n     */\r\n    static shift = (b: Bounds, pos: Vec2, origin: Vec2 = Vec2.multiply(Vec2.one, 0.5)) => {\r\n        const o = Vec2.lerpComponents(b.min, b.max, origin);\r\n        return Bounds.translate(b, Vec2.subtract(pos, o));\r\n    };\r\n\r\n    /**\r\n     * Extends bounds by a vector.\r\n     * @param b The bounds.\r\n     * @param v The extension vector.\r\n     * @returns The extended bounds.\r\n     */\r\n    static extend = (b: Bounds, v: Vec2) => {\r\n        if (v.x > 0) {\r\n            b.max = new Vec2(b.max.x + v.x, b.max.y);\r\n        } else {\r\n            b.min = new Vec2(b.min.x + v.x, b.min.y);\r\n        }\r\n        if (v.y > 0) {\r\n            b.max = new Vec2(b.max.x, b.max.y + v.y);\r\n        } else {\r\n            b.min = new Vec2(b.min.x, b.min.y + v.y);\r\n        }\r\n        return b;\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * Static class for moving the viewport in the world space.\r\n */\r\nexport default class Camera {\r\n    /**\r\n     * The position of the camera.\r\n     */\r\n    static position: Vec2 = Vec2.zero;\r\n\r\n    /**\r\n     * The rotation of the camera.\r\n     */\r\n    static rotation: number = 0;\r\n\r\n    /**\r\n     * The scale of the camera.\r\n     */\r\n    static scale: Vec2 = Vec2.one;\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Camera from './Camera';\r\nimport Mat3 from '../structures/Mat3';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * Static class for input handling.\r\n */\r\nexport default class Input {\r\n    private static singleton: Input | null = null;\r\n    private static canvas: HTMLCanvasElement | null = null;\r\n    private static keyStates: Map<string, boolean> = new Map<string, boolean>();\r\n    private static keyTransits: Map<string, boolean> = new Map<string, boolean>();\r\n    private static mouseStates: Map<number, boolean> = new Map<number, boolean>();\r\n    private static mouseTransits: Map<number, boolean> = new Map<number, boolean>();\r\n    private static mousePos: Vec2 = Vec2.zero;\r\n\r\n    constructor(canvas: HTMLCanvasElement) {\r\n        if (Input.singleton) {\r\n            console.warn(\"Input is used as a static class, do not create additional objects of Input\");\r\n            return;\r\n        }\r\n        Input.singleton = this;\r\n\r\n        // Register canvas events\r\n        Input.canvas = canvas;\r\n        canvas.onmousedown = (ev) => {\r\n            const b = ev.button;\r\n            Input.mouseStates.set(b, true);\r\n            Input.mouseTransits.set(b, true);\r\n        };\r\n        canvas.onmouseup = canvas.onmouseleave = (ev) => {\r\n            const b = ev.button;\r\n            Input.mouseStates.set(b, false);\r\n            Input.mouseTransits.set(b, true);\r\n        };\r\n        canvas.onmousemove = (ev) => {\r\n            Input.mousePos = new Vec2(ev.offsetX, ev.offsetY);\r\n        };\r\n\r\n        // Register window events\r\n        window.onkeydown = (ev) => {\r\n            const c = ev.code;\r\n            if (!ev.repeat) {\r\n                Input.keyStates.set(c, true);\r\n                Input.keyTransits.set(c, true);\r\n            }\r\n        };\r\n        window.onkeyup = (ev) => {\r\n            const c = ev.code;\r\n            Input.keyStates.set(c, false);\r\n            Input.keyTransits.set(c, true);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Clears all internal flags at the end of the frame.\r\n     * \r\n     * Called by `Petrallengine.create`.\r\n     */\r\n    endFrame() {\r\n        for (let i of Input.keyTransits.keys()) {\r\n            Input.keyTransits.set(i, false);\r\n        }\r\n        for (let i of Input.mouseTransits.keys()) {\r\n            Input.mouseTransits.set(i, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns whether a keyboard key is down.\r\n     * @param keyCode The code of the key.\r\n     * @returns Whether the key is down.\r\n     */\r\n    static isKey(keyCode: string) {\r\n        return Input.keyStates.get(keyCode) ?? false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether a keyboard key was pressed this frame.\r\n     * @param keyCode The code of the key.\r\n     * @returns Whether the key was pressed this frame.\r\n     */\r\n    static isKeyPressed(keyCode: string) {\r\n        return (Input.keyTransits.get(keyCode) ?? false) && Input.isKey(keyCode);\r\n    }\r\n\r\n    /**\r\n     * Returns whether a keyboard key was released this frame.\r\n     * @param keyCode The code of the key.\r\n     * @returns Whether the key was released this frame.\r\n     */\r\n    static isKeyReleased(keyCode: string) {\r\n        return (Input.keyTransits.get(keyCode) ?? false) && !Input.isKey(keyCode);\r\n    }\r\n\r\n    /**\r\n     * Returns whether a mouse button is down.\r\n     * @param button The mouse button.\r\n     * @returns Whether the mouse button is down.\r\n     */\r\n    static isMouse(button: number = 0) {\r\n        return Input.mouseStates.get(button) ?? false;\r\n    }\r\n\r\n    /**\r\n     * Returns whether a mouse button was pressed this frame.\r\n     * @param button The mouse button.\r\n     * @returns Whether the mouse button was pressed this frame.\r\n     */\r\n    static isMousePressed(button: number = 0) {\r\n        return (Input.mouseTransits.get(button) ?? false) && Input.isMouse(button);\r\n    }\r\n\r\n    /**\r\n     * Returns whether a mouse button was released this frame.\r\n     * @param button The mouse button.\r\n     * @returns Whether the mouse button was released this frame.\r\n     */\r\n    static isMouseReleased(button: number = 0) {\r\n        return (Input.mouseTransits.get(button) ?? false) && !Input.isMouse(button);\r\n    }\r\n\r\n    /**\r\n     * Returns the position of the mouse in the canvas.\r\n     * @returns The position of the mouse in the canvas.\r\n     */\r\n    static get mousePosition() {\r\n        return Input.mousePos;\r\n    }\r\n\r\n    /**\r\n     * Returns the normalized position of the mouse in the canvas.\r\n     * @returns The normalized position of the mouse in the canvas.\r\n     */\r\n    static get mousePositionNormalized() {\r\n        return Vec2.multiplyComponents(Input.mousePos, new Vec2(1 / Input.canvas!.width, 1 / Input.canvas!.height));\r\n    }\r\n\r\n    /**\r\n     * Returns the position on the canvas of a world position.\r\n     * @returns The position on the canvas of a world position.\r\n     */\r\n    static worldToCanvas(worldPos: Vec2) {\r\n        return Vec2.add(\r\n            Vec2.transform(\r\n                Mat3.makeTransformation(Vec2.multiply(Camera.position, -1), -Camera.rotation, Camera.scale),\r\n                worldPos),\r\n            Vec2.multiply(Vec2.fromObjWH(Input.canvas!), 0.5)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the position in the world of a canvas position.\r\n     * @returns The position in the world of a canvas position.\r\n     */\r\n    static canvasToWorld(canvasPos: Vec2) {\r\n        return Vec2.transform(\r\n            Mat3.inverse(Mat3.makeTransformation(Vec2.multiply(Camera.position, -1), -Camera.rotation, Camera.scale)),\r\n            Vec2.add(canvasPos, Vec2.multiply(Vec2.fromObjWH(Input.canvas!), -0.5))\r\n        );\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport { Snowflake } from '../Snowflake';\r\nimport Game from '../Game';\r\nimport Body from '../nodes/Body';\r\nimport CircleCollider from '../nodes/CircleCollider';\r\nimport Collider from '../nodes/Collider';\r\nimport ConvexCollider from '../nodes/ConvexCollider';\r\nimport Bounds from '../structures/Bounds';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\ninterface CollisionInfo {\r\n}\r\ninterface CircleCircleInfo extends CollisionInfo {\r\n    willIntersect: boolean,\r\n    isInterior: boolean,\r\n    intersectTime: number,\r\n    intersectPos1: Vec2,\r\n    intersectPos2: Vec2,\r\n}\r\n\r\ntype SnowflakePair = Snowflake;\r\nfunction makeSnowflakePair(id1: Snowflake, id2: Snowflake) {\r\n    if (id1 < id2)\r\n        return id1 + '|' + id2;\r\n    return id2 + '|' + id2;\r\n}\r\nfunction breakSnowflakePair(pair: SnowflakePair): [Snowflake, Snowflake] {\r\n    const items = pair.split('|');\r\n    return [items[0], items[1]];\r\n}\r\n\r\n/**\r\n * Static class for physics and collisions.\r\n */\r\nexport default class Physics {\r\n    private static singleton: Physics | null = null;\r\n    private static bodies: Map<Snowflake, Body> = new Map<Snowflake, Body>();\r\n    private static colliders: Map<Snowflake, Collider> = new Map<Snowflake, Collider>();\r\n    private static bodyColliders: Map<Snowflake, Set<Snowflake>> = new Map<Snowflake, Set<Snowflake>>();\r\n    private static colliderBodies: Map<Snowflake, Snowflake> = new Map<Snowflake, Snowflake>();\r\n    private static pairsCollided: Set<SnowflakePair> = new Set<SnowflakePair>();\r\n\r\n    constructor() {\r\n        if (Physics.singleton) {\r\n            console.warn(\"Physics is used as a static class, do not create additional objects of Physics\");\r\n            return;\r\n        }\r\n        Physics.singleton = this;\r\n    }\r\n\r\n    tick() {\r\n        let collisions: CollisionInfo[] = [];\r\n        let pairsCalled: Set<SnowflakePair> = new Set<SnowflakePair>();\r\n        function triggerBody(c1: Collider, c2: Collider) {\r\n            const b1 = Physics.bodies.get(Physics.colliderBodies.get(c1.id)!)!;\r\n            const b2 = Physics.bodies.get(Physics.colliderBodies.get(c2.id)!)!;\r\n            const pair = makeSnowflakePair(b1.id, b2.id);\r\n\r\n            if (!Physics.pairsCollided.has(pair)) {\r\n                // Call collision enter callback\r\n                Physics.pairsCollided.add(pair);\r\n                b1.onCollisionEnter?.call(b1, b2);\r\n                b2.onCollisionEnter?.call(b2, b1);\r\n            }\r\n            else {\r\n                // Call collision update callback\r\n                b1.onCollisionUpdate?.call(b1, b2);\r\n                b2.onCollisionUpdate?.call(b2, b1);\r\n            }\r\n\r\n            // Mark this pair as being called this frame\r\n            if (!pairsCalled.has(pair))\r\n                pairsCalled.add(pair);\r\n        }\r\n\r\n        // Get colliders as array\r\n        let colliders: Collider[] = Array.from(Physics.colliders.values());\r\n\r\n        // Sort by min x\r\n        colliders.sort((c1, c2) => c1.bounds.min.x - c2.bounds.min.x);\r\n\r\n        // Iterate all colliders\r\n        for (let i = 0; i < colliders.length; i++) {\r\n            const ci = colliders[i];\r\n            ci.globalTransform;\r\n            ci.regenerate();\r\n            const bi = Physics.bodies.get(Physics.colliderBodies.get(ci.id)!)!;\r\n            for (let j = i + 1; j < colliders.length; j++) {\r\n                const cj = colliders[j];\r\n                ci.globalTransform;\r\n                cj.regenerate();\r\n                const bj = Physics.bodies.get(Physics.colliderBodies.get(cj.id)!)!;\r\n\r\n                // Same body\r\n                if (bi.id === bj.id) {\r\n                    continue;\r\n                }\r\n\r\n                // --- BROAD PHASE ---\r\n\r\n                // Non-intersecting layers\r\n                if (!ci.canCollideWith(cj)) {\r\n                    continue;\r\n                }\r\n\r\n                // Extend bounds\r\n                const bndi = Bounds.extend(ci.bounds, bi.velocity);\r\n                const bndj = Bounds.extend(cj.bounds, bj.velocity);\r\n\r\n                // X limits\r\n                if (bndj.min.x > bndi.max.x) {\r\n                    break;\r\n                }\r\n\r\n                // Y overlap\r\n                if (bndi.max.y < bndj.min.y || bndi.min.y > bndj.max.y) {\r\n                    continue;\r\n                }\r\n\r\n                // BB overlap\r\n                if (!bndi.overlaps(bndj)) {\r\n                    continue;\r\n                }\r\n\r\n                // --- NARROW PHASE ---\r\n\r\n                if (ci instanceof CircleCollider && cj instanceof CircleCollider) {\r\n                    // Circle-circle\r\n                    const col = Physics.circleCircleIntersection(\r\n                        ci.globalPosition, Vec2.zero, ci.radius,\r\n                        cj.globalPosition, Vec2.zero, cj.radius);\r\n                    if (col.willIntersect) {\r\n                        collisions.push(col);\r\n                        triggerBody(ci, cj);\r\n                    }\r\n                    continue;\r\n                }\r\n                else if (ci instanceof ConvexCollider && cj instanceof ConvexCollider) {\r\n                    // Polygon-polygon\r\n                    // TODO\r\n                    continue;\r\n                }\r\n                else if (\r\n                    (ci instanceof CircleCollider && cj instanceof ConvexCollider) ||\r\n                    (ci instanceof ConvexCollider && cj instanceof CircleCollider)) {\r\n                    // Circle-polygon\r\n                    // TODO\r\n                    continue;\r\n                }\r\n                console.error(`Colliders ${typeof ci} and ${typeof cj} not supported by collision detection`)\r\n            }\r\n        }\r\n\r\n        // Clear uncalled pairs\r\n        for (const pair of Physics.pairsCollided.values()) {\r\n            const [b1id, b2id] = breakSnowflakePair(pair);\r\n            if (pairsCalled.has(pair)) {\r\n                continue;\r\n            }\r\n            const [b1, b2] = [Physics.bodies.get(b1id)!, Physics.bodies.get(b2id)!];\r\n            Physics.pairsCollided.delete(pair);\r\n            b1.onCollisionExit?.call(b1, b2);\r\n            b2.onCollisionExit?.call(b2, b1);\r\n        }\r\n\r\n        return collisions;\r\n    }\r\n\r\n    static registerBody(body: Body) {\r\n        if (Physics.bodies.has(body.id) || Physics.bodyColliders.has(body.id)) {\r\n            console.error(`Body #${body.id} already registered in physics system`);\r\n            return;\r\n        }\r\n        Physics.bodies.set(body.id, body);\r\n        Physics.bodyColliders.set(body.id, new Set<Snowflake>);\r\n    }\r\n\r\n    static registerCollider(collider: Collider, owner: Body) {\r\n        if (Physics.colliders.has(collider.id) || Physics.colliderBodies.has(collider.id)) {\r\n            console.error(`Collider #${owner.id} already registered in physics system`);\r\n            return;\r\n        }\r\n        if (!Physics.bodies.has(owner.id)) {\r\n            console.error(`Body #${owner.id} not registered in physics system`);\r\n            return;\r\n        }\r\n        if (Physics.bodyColliders.get(owner.id)?.has(collider.id) || Physics.colliderBodies.has(collider.id)) {\r\n            console.warn(`Collider #${collider.id} already registered with body #${Physics.colliderBodies.get(collider.id)} in physics system`);\r\n            return;\r\n        }\r\n        Physics.colliders.set(collider.id, collider);\r\n        Physics.colliderBodies.set(collider.id, owner.id);\r\n        Physics.bodyColliders.get(owner.id)?.add(collider.id);\r\n    }\r\n\r\n    private static rayCircleIntersection(posRay: Vec2, velRay: Vec2, posCircle: Vec2, radius: number) {\r\n        let output = {\r\n            willIntersect: false,\r\n            isInterior: false,\r\n            intersectTime: 0,\r\n        };\r\n\r\n        // Distance squared\r\n        const distSqr = Vec2.subtract(posRay, posCircle).sqrLength;\r\n\r\n        // Check if interior or exterior ray\r\n        output.isInterior = (distSqr < radius * radius);\r\n\r\n        // Ray length\r\n        const rl = velRay.length;\r\n\r\n        // Delta from start to CPA\r\n        const m = Vec2.dot(Vec2.subtract(posCircle, posRay), velRay.normalized);\r\n        if (!output.isInterior && m < 0 && distSqr > radius * radius)\r\n            return output;\r\n\r\n        // CPA\r\n        const nSqr = distSqr - m * m;\r\n        if (nSqr > radius * radius)\r\n            return output;\r\n\r\n        // Delta from collision point to CPA\r\n        const s = Math.sqrt(radius * radius - nSqr);\r\n\r\n        // Time to intersect\r\n        const it = output.isInterior\r\n            ? ((m + s) / rl)\r\n            : ((m - s) / rl);\r\n\r\n        if (it >= 0 && it <= 1) {\r\n            output.willIntersect = true;\r\n            output.intersectTime = it;\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    private static circleCircleIntersection(\r\n        pos1: Vec2, vel1: Vec2, radius1: number,\r\n        pos2: Vec2, vel2: Vec2, radius2: number) {\r\n        let output: CircleCircleInfo = {\r\n            willIntersect: false,\r\n            isInterior: false,\r\n            intersectTime: 0,\r\n            intersectPos1: Vec2.zero,\r\n            intersectPos2: Vec2.zero,\r\n        };\r\n\r\n        // Relative position of 1 from 2\r\n        const relPos = Vec2.subtract(pos1, pos2);\r\n\r\n        // Relative vel of 1 from 2\r\n        const relvel = Vec2.subtract(vel1, vel2);\r\n\r\n        // Zero relative velocity\r\n        if (relvel.sqrLength === 0) {\r\n            output.willIntersect = relPos.sqrLength <= (radius1 + radius2) * (radius1 + radius2);\r\n            return output;\r\n        }\r\n\r\n        // Relative ray\r\n        const relRayPos = pos1.copy();\r\n        const relRayVel = relvel;\r\n\r\n        // Check if interior or exterior intersection\r\n        output.isInterior = (relPos.sqrLength < (radius1 - radius2) * (radius1 - radius2));\r\n        if (!output.isInterior && relPos.sqrLength < (radius1 + radius2) * (radius1 + radius2)) {\r\n            // Overlapping circles, I don't care about this case\r\n            return output;\r\n        }\r\n\r\n        // Relative circle\r\n        const relCirclePos = pos2.copy();\r\n        const relCircleRadius = output.isInterior ? Math.abs((radius1 - radius2)) : radius1 + radius2;\r\n\r\n        // Ray-circle\r\n        const col = Physics.rayCircleIntersection(relRayPos, relRayVel, relCirclePos, relCircleRadius);\r\n\r\n        // Intersection points\r\n        if (col.willIntersect) {\r\n            output.willIntersect = col.willIntersect;\r\n            output.intersectTime = col.intersectTime;\r\n            output.intersectPos1 = Vec2.add(pos1, Vec2.multiply(vel1, col.intersectTime));\r\n            output.intersectPos2 = Vec2.add(pos2, Vec2.multiply(vel2, col.intersectTime));\r\n        }\r\n        return output;\r\n    }\r\n\r\n    private static circleCircleResponse(\r\n        normal: Vec2, intersectTime: number,\r\n        vel1: Vec2, mass1: number, intersectPos1: Vec2,\r\n        vel2: Vec2, mass2: number, intersectPos2: Vec2) {\r\n        let output = {\r\n            reflVel1: Vec2.zero,\r\n            reflVel2: Vec2.zero,\r\n            reflPos1: Vec2.zero,\r\n            reflPos2: Vec2.zero,\r\n        };\r\n\r\n        // Just in case\r\n        const n = normal.normalized;\r\n\r\n        // Magnitude of velocity in direction of normal\r\n        const a1 = Vec2.dot(vel1, n);\r\n        const a2 = Vec2.dot(vel2, n);\r\n\r\n        // Factor of normal to add\r\n        const f1 = -2 * (a1 - a2) * (mass2 < Infinity ? (mass2 / (mass1 + mass2)) : 1);\r\n        const f2 = +2 * (a1 - a2) * (mass1 < Infinity ? (mass1 / (mass1 + mass2)) : 1);\r\n\r\n        output.reflVel1 = Vec2.add(vel1, Vec2.multiply(n, f1));\r\n        output.reflVel2 = Vec2.add(vel2, Vec2.multiply(n, f2));\r\n        output.reflPos1 = Vec2.add(intersectPos1, Vec2.multiply(output.reflVel1, (1 - intersectTime)));\r\n        output.reflPos2 = Vec2.add(intersectPos2, Vec2.multiply(output.reflVel2, (1 - intersectTime)));\r\n\r\n        return output;\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Bounds from '../structures/Bounds';\r\nimport Collider from './Collider';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * A node that has a circle collider shape.\r\n */\r\nexport default class CircleCollider extends Collider {\r\n    private _radius: number = 1;\r\n\r\n    /** The radius of the circle. */\r\n    get radius() { return this._radius; }\r\n    set radius(value: number) { this._radius = Math.max(value, 0); }\r\n\r\n    regenerate() {\r\n        this._bounds = new Bounds(\r\n            Vec2.subtract(this.globalPosition, new Vec2(this._radius, this._radius)),\r\n            Vec2.add(this.globalPosition, new Vec2(this._radius, this._radius)));\r\n    }\r\n\r\n    onDebugDraw(context: CanvasRenderingContext2D): void {\r\n        // Draw vertices\r\n        context.strokeStyle = \"#ff00ff\";\r\n        context.beginPath();\r\n        context.arc(this.globalPosition.x, this.globalPosition.y, this.radius, 0, 360);\r\n        context.stroke();\r\n\r\n        super.onDebugDraw(context);\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Collider from './Collider';\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * Base class for convex polygon colliders\r\n */\r\nexport default abstract class ConvexCollider extends Collider {\r\n    protected _vertices: Vec2[] = [];\r\n    protected _axes: Vec2[] = [];\r\n\r\n    /** The globally positioned vertices of the collider. */\r\n    get vertices() { return this._vertices.slice(); }\r\n\r\n    /** The axes of this collider for SAT. */\r\n    get axes() { return this._axes.slice(); }\r\n\r\n    onDebugDraw(context: CanvasRenderingContext2D): void {\r\n        // Draw vertices\r\n        context.strokeStyle = \"#ff00ff\";\r\n        context.beginPath();\r\n        for (let i = 0; i <= this._vertices.length; ++i) {\r\n            const v = this._vertices[i % this._vertices.length];\r\n            if (i == 0) {\r\n                context.moveTo(v.x, v.y);\r\n            }\r\n            else {\r\n                context.lineTo(v.x, v.y);\r\n            }\r\n        }\r\n        context.stroke();\r\n\r\n        // Draw bb\r\n        context.strokeStyle = \"#00ffff\";\r\n        context.strokeRect(\r\n            this._bounds.min.x,\r\n            this._bounds.min.y,\r\n            this._bounds.size.x,\r\n            this._bounds.size.y);\r\n\r\n        super.onDebugDraw(context);\r\n    }\r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Body from './Body';\r\n\r\n/**\r\n * A node that responds to collisions but not physics.\r\n*/\r\nexport default class CollisionBody extends Body {\r\n    \r\n}\r\n","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport Color from '../structures/Color';\r\nimport IDrawable from './IDrawable';\r\nimport Node from './Node'\r\nimport Vec2 from '../structures/Vec2';\r\n\r\n/**\r\n * A node that draws an image on the canvas.\r\n*/\r\nexport default class Sprite extends Node implements IDrawable {\r\n    private static bitmapStore: Map<string, ImageBitmap> = new Map<string, ImageBitmap>();\r\n    private static workingCanvas = new OffscreenCanvas(256, 256);\r\n\r\n    private _image: string | null = null;\r\n    private _color: Color = Color.white;\r\n    private bitmap: ImageBitmap | null = null;\r\n\r\n    /** The normalized pivot. */\r\n    pivot: Vec2 = Vec2.multiply(Vec2.one, 0.5);\r\n\r\n    onDraw(context: CanvasRenderingContext2D): void {\r\n        if (this.bitmap) {\r\n            context.save();\r\n            context.translate(-this.pivot.x * this.bitmap.width, -this.pivot.y * this.bitmap.height);\r\n            context.drawImage(this.bitmap, 0, 0);\r\n            context.restore();\r\n        }\r\n    }\r\n\r\n    /** The image path. */\r\n    get image() { return this._image; }\r\n    set image(value: string | null) {\r\n        const changed = this._image !== value;\r\n        this._image = value;\r\n        if (changed) {\r\n            this.updateBitmap();\r\n        }\r\n    }\r\n\r\n    /** The color. */\r\n    get color() { return this._color; }\r\n    set color(value: Color) {\r\n        const changed = this._color !== value;\r\n        this._color = value;\r\n        if (changed) {\r\n            this.updateBitmap();\r\n        }\r\n    }\r\n\r\n    private async updateBitmap() {\r\n        if (this._image === null) {\r\n            this.bitmap = null;\r\n            return;\r\n        }\r\n        const bmp = await Sprite.load(this._image);\r\n        if (this.color.r == 1 && this.color.g == 1 && this.color.b == 1 && this.color.a == 1) {\r\n            this.bitmap = bmp;\r\n        }\r\n        else {\r\n            let data = Sprite.bitmapToData(bmp);\r\n            Sprite.colorise(data, this.color);\r\n            this.bitmap = Sprite.dataToBitmap(data);\r\n        }\r\n    }\r\n\r\n    private static load(path: string) {\r\n        if (Sprite.bitmapStore.has(path)) {\r\n            return new Promise<ImageBitmap>((resolve) => { resolve(Sprite.bitmapStore.get(path)!) });\r\n        }\r\n        return new Promise<ImageBitmap>((resolve) => {\r\n            let image = new Image();\r\n            image.onload = async () => {\r\n                let bmp = await createImageBitmap(image, 0, 0, image.width, image.height);\r\n                Sprite.bitmapStore.set(path, bmp);\r\n                image.remove();\r\n                resolve(bmp);\r\n            };\r\n            image.src = path;\r\n        });\r\n    }\r\n\r\n    private static unload(path: string) {\r\n        Sprite.bitmapStore.get(path)?.close();\r\n        Sprite.bitmapStore.delete(path);\r\n    }\r\n\r\n    private static bitmapToData(bmp: ImageBitmap) {\r\n        if (Sprite.workingCanvas.width < bmp.width) {\r\n            Sprite.workingCanvas.width = bmp.width;\r\n        }\r\n        if (Sprite.workingCanvas.height < bmp.height) {\r\n            Sprite.workingCanvas.height = bmp.height;\r\n        }\r\n        let ctx = Sprite.workingCanvas.getContext('2d', { willReadFrequently: true })!;\r\n        ctx.clearRect(0, 0, bmp.width, bmp.height);\r\n        ctx.drawImage(bmp, 0, 0);\r\n        return ctx.getImageData(0, 0, bmp.width, bmp.height);\r\n    }\r\n\r\n    private static dataToBitmap(dat: ImageData) {\r\n        if (Sprite.workingCanvas.width != dat.width) {\r\n            Sprite.workingCanvas.width = dat.width;\r\n        }\r\n        if (Sprite.workingCanvas.height != dat.height) {\r\n            Sprite.workingCanvas.height = dat.height;\r\n        }\r\n        let ctx = Sprite.workingCanvas.getContext('2d', { willReadFrequently: true })!;\r\n        ctx.clearRect(0, 0, dat.width, dat.height);\r\n        ctx.putImageData(dat, 0, 0);\r\n        return Sprite.workingCanvas.transferToImageBitmap();\r\n    }\r\n\r\n    private static colorise(img: ImageData, color: Color) {\r\n        for (let p = 0; p < img.data.length; p += 4) {\r\n            const [r, g, b] = [p, p + 1, p + 2];\r\n            img.data[r] *= color.r;\r\n            img.data[g] *= color.g;\r\n            img.data[b] *= color.b;\r\n        }\r\n    }\r\n}","/**\r\n * @author Petraller <me@petraller.com>\r\n */\r\n\r\nimport '../Math';\r\nimport ICopyable from './ICopyable';\r\nimport IEquatable from './IEquatable';\r\n\r\n/**\r\n * Representation of a RGBA color.\r\n */\r\nexport default class Color implements ICopyable, IEquatable {\r\n    /** The red component. */\r\n    r: number = 0;\r\n    /** The green component. */\r\n    g: number = 0;\r\n    /** The blue component. */\r\n    b: number = 0;\r\n    /** The alpha component. */\r\n    a: number = 1;\r\n\r\n    constructor(r: number, g: number, b: number, a?: number) {\r\n        this.r = Math.clamp(r, 0, 1);\r\n        this.g = Math.clamp(g, 0, 1);\r\n        this.b = Math.clamp(b, 0, 1);\r\n        this.a = Math.clamp(a ?? 1, 0, 1);\r\n    }\r\n\r\n    copy = () => new Color(this.r, this.g, this.b, this.a);\r\n    copyFrom = (other: Color) => { this.r = other.r; this.g = other.g; this.b = other.b, this.a = other.a; return this; };\r\n    equals = (other: Color) => this.r == other.r && this.g == other.g && this.b == other.b && this.a == other.a;\r\n\r\n    /**\r\n     * Converts the color to its #RRGGBBAA hexadecimal string representation.\r\n     * @param hasAlpha Whether to include the alpha channel.\r\n     * @returns The hexadecimal string representation.\r\n     */\r\n    toHexString = (hasAlpha: boolean = false) => {\r\n        let str: string = \"#\";\r\n        str += ((this.r * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        str += ((this.g * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        str += ((this.b * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        if (hasAlpha) str += ((this.a * 255) & 0xFF).toString(16).padStart(2, '0');\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * Converts the color to its HSV representation.\r\n     * @returns The HSV representation.\r\n     */\r\n    toHSV = () => {\r\n        const cmax = Math.max(this.r, this.g, this.b);\r\n        const cmin = Math.min(this.r, this.g, this.b);\r\n        const delta = cmax - cmin;\r\n        let [h, s, v] = [0, cmax === 0 ? 0 : delta / cmax, cmax];\r\n        if (cmax === this.r) {\r\n            h = Math.mod((this.g - this.b) / delta, 6);\r\n        }\r\n        else if (cmax === this.g) {\r\n            h = (this.g - this.b) / delta + 2;\r\n        }\r\n        else {\r\n            h = (this.g - this.b) / delta + 4;\r\n        }\r\n        return { h, s, v };\r\n    }\r\n\r\n    /** Black. */\r\n    static get black() { return new Color(0, 0, 0); }\r\n    /** Blue. */\r\n    static get blue() { return new Color(0, 0, 1); }\r\n    /** Green. */\r\n    static get green() { return new Color(0, 1, 0); }\r\n    /** Cyan. */\r\n    static get cyan() { return new Color(0, 1, 1); }\r\n    /** Red. */\r\n    static get red() { return new Color(1, 0, 0); }\r\n    /** Magenta. */\r\n    static get magenta() { return new Color(1, 0, 1); }\r\n    /** Yellow. */\r\n    static get yellow() { return new Color(1, 1, 0); }\r\n    /** White. */\r\n    static get white() { return new Color(1, 1, 1); }\r\n    /** Grey. */\r\n    static get grey() { return new Color(0.5, 0.5, 0.5); }\r\n    /** Transparent. */\r\n    static get transparent() { return new Color(0, 0, 0, 0); }\r\n\r\n    /**\r\n     * Linearly interpolates from one color to another.\r\n     * @param c1 The first color.\r\n     * @param c2 The second color.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated color.\r\n     */\r\n    static lerp(c1: Color, c2: Color, t: number) {\r\n        return new Color(\r\n            c1.r * (1 - t) + c2.r * t,\r\n            c1.g * (1 - t) + c2.g * t,\r\n            c1.b * (1 - t) + c2.b * t,\r\n            c1.a * (1 - t) + c2.a * t);\r\n    }\r\n\r\n    /**\r\n     * Spherically linearly interpolates from one color to another.\r\n     * @param c1 The first color.\r\n     * @param c2 The second color.\r\n     * @param t The amount to interpolate by.\r\n     * @returns The interpolated color.\r\n     */\r\n    static slerp(c1: Color, c2: Color, t: number) {\r\n        const func = (t: number) => Math.sin(t * Math.PI / 2)\r\n        const [u, v] = [func(1 - t), func(t)];\r\n        return new Color(\r\n            c1.r * u + c2.r * v,\r\n            c1.g * u + c2.g * v,\r\n            c1.b * u + c2.b * v,\r\n            c1.a * u + c2.a * v);\r\n    }\r\n\r\n    /**\r\n     * Creates a color from its hexadecimal string representation.\r\n     * @param str The hexadecimal string representation.\r\n     * @returns The color.\r\n     */\r\n    static fromHexString = (str: string) => {\r\n        str = str.trim();\r\n        const r = parseInt(str.substring(1, 3), 16);\r\n        const g = parseInt(str.substring(3, 5), 16);\r\n        const b = parseInt(str.substring(5, 7), 16);\r\n        const a = str.length >= 7 ? parseInt(str.substring(7, 9), 16) : 255;\r\n        return new Color(r / 255, g / 255, b / 255, a / 255);\r\n    }\r\n\r\n    /**\r\n     * Creates a color from its HSV representation.\r\n     * @param h The hue.\r\n     * @param s The saturation.\r\n     * @param v The value.\r\n     * @returns The color.\r\n     */\r\n    static fromHSV = (h: number, s: number, v: number) => {\r\n        h = h * 360;\r\n        const c = s * v;\r\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1));\r\n        const m = v - c;\r\n        let [r, g, b] = [0, 0, 0];\r\n        if (h < 60) {\r\n            [r, g, b] = [c, x, 0];\r\n        }\r\n        else if (h < 120) {\r\n            [r, g, b] = [x, c, 0];\r\n        }\r\n        else if (h < 180) {\r\n            [r, g, b] = [0, c, x];\r\n        }\r\n        else if (h < 240) {\r\n            [r, g, b] = [0, x, c];\r\n        }\r\n        else if (h < 300) {\r\n            [r, g, b] = [x, 0, c];\r\n        }\r\n        else {\r\n            [r, g, b] = [c, 0, x];\r\n        }\r\n        return new Color(r + m, g + m, b + m);\r\n    }\r\n}"],"names":[],"version":3,"file":"Petrallengine.mjs.map"}